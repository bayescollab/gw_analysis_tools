<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GW Analysis Tools: src/fisher.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GW Analysis Tools
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fisher.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="fisher_8h_source.html">fisher.h</a>&gt;</code><br />
<code>#include &lt;adolc/adouble.h&gt;</code><br />
<code>#include &lt;adolc/adolc.h&gt;</code><br />
<code>#include &lt;adolc/drivers/drivers.h&gt;</code><br />
<code>#include &lt;adolc/taping.h&gt;</code><br />
<code>#include &lt;adolc/adolc_sparse.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="detector__util_8h_source.html">detector_util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IMRPhenomD_8h_source.html">IMRPhenomD.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IMRPhenomP_8h_source.html">IMRPhenomP.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ppE__IMRPhenomD_8h_source.html">ppE_IMRPhenomD.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="waveform__generator_8h_source.html">waveform_generator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="waveform__util_8h_source.html">waveform_util.h</a>&quot;</code><br />
<code>#include &lt;gsl/gsl_interp.h&gt;</code><br />
<code>#include &lt;gsl/gsl_errno.h&gt;</code><br />
<code>#include &lt;gsl/gsl_spline.h&gt;</code><br />
<code>#include &lt;gsl/gsl_integration.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for fisher.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="fisher_8cpp__incl.png" border="0" usemap="#src_2fisher_8cpp" alt=""/></div>
<map name="src_2fisher_8cpp" id="src_2fisher_8cpp">
<area shape="rect" href="fisher_8h.html" title="fisher.h" alt="" coords="211,155,276,181"/>
<area shape="rect" href="util_8h.html" title="util.h" alt="" coords="629,229,680,256"/>
<area shape="rect" href="detector__util_8h.html" title="detector_util.h" alt="" coords="352,155,456,181"/>
<area shape="rect" href="IMRPhenomD_8h.html" title="IMRPhenomD.h" alt="" coords="694,155,810,181"/>
<area shape="rect" href="IMRPhenomP_8h.html" title="IMRPhenomP.h" alt="" coords="626,80,741,107"/>
<area shape="rect" href="ppE__IMRPhenomD_8h.html" title="ppE_IMRPhenomD.h" alt="" coords="765,80,912,107"/>
<area shape="rect" href="waveform__generator_8h.html" title="waveform_generator.h" alt="" coords="36,155,187,181"/>
<area shape="rect" href="waveform__util_8h.html" title="waveform_util.h" alt="" coords="336,80,450,107"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9794311b4c41baa77ce1975de890115a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#a9794311b4c41baa77ce1975de890115a">fisher_numerical</a> (double *frequency, int length, string generation_method, string detector, double **output, int dimension, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *parameters, int order, int *amp_tapes, int *phase_tapes, double *noise)</td></tr>
<tr class="memdesc:a9794311b4c41baa77ce1975de890115a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the fisher matrix for the given arguments.  <a href="fisher_8cpp.html#a9794311b4c41baa77ce1975de890115a">More...</a><br /></td></tr>
<tr class="separator:a9794311b4c41baa77ce1975de890115a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8bac46d59b2f9e40c199557b57ebd6"><td class="memItemLeft" align="right" valign="top"><a id="a0e8bac46d59b2f9e40c199557b57ebd6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_derivatives</b> (std::complex&lt; double &gt; **response_deriv, double *frequencies, int length, int dimension, string detector, string gen_method, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *parameters, int order)</td></tr>
<tr class="separator:a0e8bac46d59b2f9e40c199557b57ebd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ee1eb7de2af646ec16426c9660f7e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#a91ee1eb7de2af646ec16426c9660f7e9">fisher_autodiff_batch_mod</a> (double *frequency, int length, std::string generation_method, std::string detector, double **output, int base_dimension, int full_dimension, <a class="el" href="classgen__params.html">gen_params</a> *parameters, int *amp_tapes, int *phase_tapes, double *noise)</td></tr>
<tr class="memdesc:a91ee1eb7de2af646ec16426c9660f7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the fisher matrix for the given arguments to within numerical error using automatic differention in `&lsquo;batch&rsquo;' mode for modifications to GR.  <a href="fisher_8cpp.html#a91ee1eb7de2af646ec16426c9660f7e9">More...</a><br /></td></tr>
<tr class="separator:a91ee1eb7de2af646ec16426c9660f7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d084e6f4a371edfc51b6e2a1324d970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#a3d084e6f4a371edfc51b6e2a1324d970">fisher_autodiff_interp</a> (double *frequency, int length, std::string generation_method, std::string detector, double **output, int dimension, <a class="el" href="classgen__params.html">gen_params</a> *parameters, int downsampling_factor, int *amp_tapes, int *phase_tapes, double *noise)</td></tr>
<tr class="memdesc:a3d084e6f4a371edfc51b6e2a1324d970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the fisher matrix for the given arguments to within numerical error using automatic differention - slower than the numerical version.  <a href="fisher_8cpp.html#a3d084e6f4a371edfc51b6e2a1324d970">More...</a><br /></td></tr>
<tr class="separator:a3d084e6f4a371edfc51b6e2a1324d970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32601e9b8b1e1e36905da85a4acc5d43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#a32601e9b8b1e1e36905da85a4acc5d43">fisher_autodiff</a> (double *frequency, int length, std::string generation_method, std::string detector, double **output, int dimension, <a class="el" href="classgen__params.html">gen_params</a> *parameters, int *amp_tapes, int *phase_tapes, double *noise)</td></tr>
<tr class="memdesc:a32601e9b8b1e1e36905da85a4acc5d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the fisher matrix for the given arguments to within numerical error using automatic differention - slower than the numerical version.  <a href="fisher_8cpp.html#a32601e9b8b1e1e36905da85a4acc5d43">More...</a><br /></td></tr>
<tr class="separator:a32601e9b8b1e1e36905da85a4acc5d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8feb32ace0a3f96caa05a3ebe36741c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#ab8feb32ace0a3f96caa05a3ebe36741c">calculate_derivatives_autodiff</a> (double *frequency, int length, int dimension, std::string generation_method, <a class="el" href="classgen__params.html">gen_params</a> *parameters, std::complex&lt; double &gt; **waveform_deriv, int *waveform_tapes, std::string detector)</td></tr>
<tr class="memdesc:ab8feb32ace0a3f96caa05a3ebe36741c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivatives of the detector response using automatic differentiation.  <a href="fisher_8cpp.html#ab8feb32ace0a3f96caa05a3ebe36741c">More...</a><br /></td></tr>
<tr class="separator:ab8feb32ace0a3f96caa05a3ebe36741c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08ddae761a3005399569df9dd80d261"><td class="memItemLeft" align="right" valign="top"><a id="ad08ddae761a3005399569df9dd80d261"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>num_src_params</b> (int *N_src_params, std::string generation_method, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params)</td></tr>
<tr class="separator:ad08ddae761a3005399569df9dd80d261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada801108b3d850efe063d91c2d43176"><td class="memItemLeft" align="right" valign="top"><a id="aada801108b3d850efe063d91c2d43176"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reduce_extrinsic</b> (int *src_params, int N_src_params, std::string generation_method, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params)</td></tr>
<tr class="separator:aada801108b3d850efe063d91c2d43176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ccb5fbfa7dde9dc8d7fb1f38ef5e16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#a98ccb5fbfa7dde9dc8d7fb1f38ef5e16">time_phase_corrected_derivative_autodiff_numerical</a> (double **dt, int length, double *frequencies, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, int dimension, bool correct_time)</td></tr>
<tr class="memdesc:a98ccb5fbfa7dde9dc8d7fb1f38ef5e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase.  <a href="fisher_8cpp.html#a98ccb5fbfa7dde9dc8d7fb1f38ef5e16">More...</a><br /></td></tr>
<tr class="separator:a98ccb5fbfa7dde9dc8d7fb1f38ef5e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b5ad58c5308a1311a93a58f2169e40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#ae6b5ad58c5308a1311a93a58f2169e40">time_phase_corrected_derivative_autodiff</a> (double **dt, int length, double *frequencies, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, int dimension, bool correct_time)</td></tr>
<tr class="memdesc:ae6b5ad58c5308a1311a93a58f2169e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase.  <a href="fisher_8cpp.html#ae6b5ad58c5308a1311a93a58f2169e40">More...</a><br /></td></tr>
<tr class="separator:ae6b5ad58c5308a1311a93a58f2169e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093a18b5f2d85ddd1cd37cc22137ae92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#a093a18b5f2d85ddd1cd37cc22137ae92">time_phase_corrected_derivative_autodiff_sparse</a> (double **dt, int length, double *frequencies, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, int dimension, bool correct_time)</td></tr>
<tr class="memdesc:a093a18b5f2d85ddd1cd37cc22137ae92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase.  <a href="fisher_8cpp.html#a093a18b5f2d85ddd1cd37cc22137ae92">More...</a><br /></td></tr>
<tr class="separator:a093a18b5f2d85ddd1cd37cc22137ae92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3566a9d2c5776b7769f1452bf3f80f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#ab3566a9d2c5776b7769f1452bf3f80f3">time_phase_corrected_derivative_autodiff_full_hess</a> (double **dt, int length, double *frequencies, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, int dimension, bool correct_time)</td></tr>
<tr class="memdesc:ab3566a9d2c5776b7769f1452bf3f80f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase.  <a href="fisher_8cpp.html#ab3566a9d2c5776b7769f1452bf3f80f3">More...</a><br /></td></tr>
<tr class="separator:ab3566a9d2c5776b7769f1452bf3f80f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430217adb3e9baf50041ab7fbbd9b2b9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a430217adb3e9baf50041ab7fbbd9b2b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#a430217adb3e9baf50041ab7fbbd9b2b9">time_phase_corrected_derivative_numerical</a> (T **dt, int length, T *frequencies, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *params, std::string generation_method, int dimension, bool correct_time)</td></tr>
<tr class="memdesc:a430217adb3e9baf50041ab7fbbd9b2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase &ndash; numerical.  <a href="fisher_8cpp.html#a430217adb3e9baf50041ab7fbbd9b2b9">More...</a><br /></td></tr>
<tr class="separator:a430217adb3e9baf50041ab7fbbd9b2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46b2d580bf50b5de9c7eb8bf9d361d1"><td class="memItemLeft" align="right" valign="top"><a id="ad46b2d580bf50b5de9c7eb8bf9d361d1"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>time_phase_corrected_derivative_numerical&lt; double &gt;</b> (double **, int, double *, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, std::string, int, bool)</td></tr>
<tr class="separator:ad46b2d580bf50b5de9c7eb8bf9d361d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64b3163d121d715a0eaa22a039ffbe1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#ad64b3163d121d715a0eaa22a039ffbe1">local_generation_method</a> (std::string generation_method)</td></tr>
<tr class="memdesc:ad64b3163d121d715a0eaa22a039ffbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for mapping generation method string to one accepted by the waveform_generation routines.  <a href="fisher_8cpp.html#ad64b3163d121d715a0eaa22a039ffbe1">More...</a><br /></td></tr>
<tr class="separator:ad64b3163d121d715a0eaa22a039ffbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af071af4a0f6f8ab05c1cdc76a275cd49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#af071af4a0f6f8ab05c1cdc76a275cd49">detect_adjust_parameters</a> (double *freq_boundaries, double *grad_freqs, int *boundary_num, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *input_params, std::string generation_method, std::string detector, int dim)</td></tr>
<tr class="memdesc:af071af4a0f6f8ab05c1cdc76a275cd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust parameters for detector specific configurations (namely, LISA introduces extra transitions that needs to be accounted for)  <a href="fisher_8cpp.html#af071af4a0f6f8ab05c1cdc76a275cd49">More...</a><br /></td></tr>
<tr class="separator:af071af4a0f6f8ab05c1cdc76a275cd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc06575e6f7b404a56d9c5fa8041ddf5"><td class="memItemLeft" align="right" valign="top"><a id="abc06575e6f7b404a56d9c5fa8041ddf5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#abc06575e6f7b404a56d9c5fa8041ddf5">unpack_parameters</a> (double *parameters, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *input_params, std::string generation_method, int dimension, bool *log_factors)</td></tr>
<tr class="memdesc:abc06575e6f7b404a56d9c5fa8041ddf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks the input <a class="el" href="classgen__params.html" title="convience wrapper for the gen_params_base class">gen_params</a> object into a double array for use with the fisher routines. <br /></td></tr>
<tr class="separator:abc06575e6f7b404a56d9c5fa8041ddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9abf5e34ebefb45c534eacd8c6d408b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae9abf5e34ebefb45c534eacd8c6d408b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#ae9abf5e34ebefb45c534eacd8c6d408b">repack_parameters</a> (T *avec_parameters, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *a_params, std::string generation_method, int dim, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *original_params)</td></tr>
<tr class="memdesc:ae9abf5e34ebefb45c534eacd8c6d408b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repack the parameters from an adouble vector to a gen_params_base&lt;adouble&gt; object and freqeuncy.  <a href="fisher_8cpp.html#ae9abf5e34ebefb45c534eacd8c6d408b">More...</a><br /></td></tr>
<tr class="separator:ae9abf5e34ebefb45c534eacd8c6d408b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92eebd80a98aa7fb1872bb8700702f77"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a92eebd80a98aa7fb1872bb8700702f77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#a92eebd80a98aa7fb1872bb8700702f77">repack_non_parameter_options</a> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *waveform_params, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *input_params, std::string gen_method)</td></tr>
<tr class="memdesc:a92eebd80a98aa7fb1872bb8700702f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilitiy to transfer non-parameter options from one <a class="el" href="classgen__params.html" title="convience wrapper for the gen_params_base class">gen_params</a> structure to another.  <a href="fisher_8cpp.html#a92eebd80a98aa7fb1872bb8700702f77">More...</a><br /></td></tr>
<tr class="separator:a92eebd80a98aa7fb1872bb8700702f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcafe56ca448601bb2b04f5228181742"><td class="memItemLeft" align="right" valign="top"><a id="adcafe56ca448601bb2b04f5228181742"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>repack_non_parameter_options&lt; double &gt;</b> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, std::string)</td></tr>
<tr class="separator:adcafe56ca448601bb2b04f5228181742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1145b36a382264d5a39f79facf8f9be"><td class="memItemLeft" align="right" valign="top"><a id="ab1145b36a382264d5a39f79facf8f9be"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>repack_non_parameter_options&lt; adouble &gt;</b> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; adouble &gt; *, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, std::string)</td></tr>
<tr class="separator:ab1145b36a382264d5a39f79facf8f9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf636e94d93a8afa6e1849af23147f11"><td class="memTemplParams" colspan="2"><a id="aaf636e94d93a8afa6e1849af23147f11"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aaf636e94d93a8afa6e1849af23147f11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deallocate_non_param_options</b> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *waveform_params, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *input_params, std::string gen_method)</td></tr>
<tr class="separator:aaf636e94d93a8afa6e1849af23147f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e9b01d2120925528a0152d1d1de598"><td class="memItemLeft" align="right" valign="top"><a id="a40e9b01d2120925528a0152d1d1de598"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate_non_param_options&lt; double &gt;</b> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, std::string)</td></tr>
<tr class="separator:a40e9b01d2120925528a0152d1d1de598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a33f43298311988222599b47d4b992"><td class="memItemLeft" align="right" valign="top"><a id="ad3a33f43298311988222599b47d4b992"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate_non_param_options&lt; adouble &gt;</b> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; adouble &gt; *, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, std::string)</td></tr>
<tr class="separator:ad3a33f43298311988222599b47d4b992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae7abfd22bc80580996b8f677be9156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#acae7abfd22bc80580996b8f677be9156">calculate_fisher_elements_batch</a> (double *frequency, int length, int base_dimension, int full_dimension, std::complex&lt; double &gt; **response_deriv, double **output, double *psd)</td></tr>
<tr class="memdesc:acae7abfd22bc80580996b8f677be9156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subroutine to calculate fisher elements for a subset of the fisher.  <a href="fisher_8cpp.html#acae7abfd22bc80580996b8f677be9156">More...</a><br /></td></tr>
<tr class="separator:acae7abfd22bc80580996b8f677be9156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da03c0eee5317e59d67f85dd6358494"><td class="memItemLeft" align="right" valign="top"><a id="a8da03c0eee5317e59d67f85dd6358494"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_fisher_elements</b> (double *frequency, int length, int dimension, std::complex&lt; double &gt; **response_deriv, double **output, double *psd)</td></tr>
<tr class="separator:a8da03c0eee5317e59d67f85dd6358494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35526714c92028b3083eee115558984a"><td class="memItemLeft" align="right" valign="top"><a id="a35526714c92028b3083eee115558984a"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>repack_parameters&lt; adouble &gt;</b> (adouble *, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; adouble &gt; *, std::string, int, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *)</td></tr>
<tr class="separator:a35526714c92028b3083eee115558984a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339139bedbb1eb4a31f068d0e635bc8a"><td class="memItemLeft" align="right" valign="top"><a id="a339139bedbb1eb4a31f068d0e635bc8a"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>repack_parameters&lt; double &gt;</b> (double *, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, std::string, int, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *)</td></tr>
<tr class="separator:a339139bedbb1eb4a31f068d0e635bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06005d743a31e704ea51c2e1b2f7d69b"><td class="memItemLeft" align="right" valign="top"><a id="a06005d743a31e704ea51c2e1b2f7d69b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prep_gsl_subroutine</b> (<a class="el" href="structgsl__subroutine.html">gsl_subroutine</a> *params_packed)</td></tr>
<tr class="separator:a06005d743a31e704ea51c2e1b2f7d69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8560e6f0a861ee30845613592e70b7c"><td class="memItemLeft" align="right" valign="top"><a id="ae8560e6f0a861ee30845613592e70b7c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tape_phase_gsl_subroutine</b> (<a class="el" href="structgsl__subroutine.html">gsl_subroutine</a> *params_packed)</td></tr>
<tr class="separator:ae8560e6f0a861ee30845613592e70b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447ef9a0bb4954bab835f418932ce61d"><td class="memItemLeft" align="right" valign="top"><a id="a447ef9a0bb4954bab835f418932ce61d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tape_time_gsl_subroutine</b> (<a class="el" href="structgsl__subroutine.html">gsl_subroutine</a> *params_packed)</td></tr>
<tr class="separator:a447ef9a0bb4954bab835f418932ce61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76283082e8f4a45365dda6c58f25e3f"><td class="memItemLeft" align="right" valign="top"><a id="ad76283082e8f4a45365dda6c58f25e3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tape_waveform_gsl_subroutine</b> (<a class="el" href="structgsl__subroutine.html">gsl_subroutine</a> *params_packed)</td></tr>
<tr class="separator:ad76283082e8f4a45365dda6c58f25e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6379dc95a9280ff960f5ebd8eacba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#a0c6379dc95a9280ff960f5ebd8eacba0">fisher_autodiff_gsl_integration</a> (double *frequency_bounds, string generation_method, string sensitivity_curve, string detector, double **output, double **error, int dimension, <a class="el" href="classgen__params.html">gen_params</a> *parameters, double abserr, double relerr)</td></tr>
<tr class="memdesc:a0c6379dc95a9280ff960f5ebd8eacba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine that implements GSL numerical integration to calculate the Fishers.  <a href="fisher_8cpp.html#a0c6379dc95a9280ff960f5ebd8eacba0">More...</a><br /></td></tr>
<tr class="separator:a0c6379dc95a9280ff960f5ebd8eacba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62f3397f996f468b5d78780df8a3167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#af62f3397f996f468b5d78780df8a3167">fisher_autodiff_gsl_integration</a> (double *frequency_bounds, string generation_method, string sensitivity_curve, string detector, double **output, double **error, int dimension, <a class="el" href="classgen__params.html">gen_params</a> *parameters, double abserr, double relerr, std::string error_log, bool logerr)</td></tr>
<tr class="memdesc:af62f3397f996f468b5d78780df8a3167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine that implements GSL numerical integration to calculate the Fishers.  <a href="fisher_8cpp.html#af62f3397f996f468b5d78780df8a3167">More...</a><br /></td></tr>
<tr class="separator:af62f3397f996f468b5d78780df8a3167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ec10cb30ab1ca997e3c501d9927c1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#a51ec10cb30ab1ca997e3c501d9927c1a">fisher_autodiff_gsl_integration_batch_mod</a> (double *frequency_bounds, string generation_method, string sensitivity_curve, string detector, double **output, double **error, int base_dimension, int full_dimension, <a class="el" href="classgen__params.html">gen_params</a> *parameters, double abserr, double relerr)</td></tr>
<tr class="memdesc:a51ec10cb30ab1ca997e3c501d9927c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine that implements GSL numerical integration to calculate the Fishers &ndash; batch modifications version.  <a href="fisher_8cpp.html#a51ec10cb30ab1ca997e3c501d9927c1a">More...</a><br /></td></tr>
<tr class="separator:a51ec10cb30ab1ca997e3c501d9927c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c44f9e3bf774c7230d972c64b81326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#a00c44f9e3bf774c7230d972c64b81326">fisher_autodiff_gsl_integration_batch_mod</a> (double *frequency_bounds, string generation_method, string sensitivity_curve, string detector, double **output, double **error, int base_dimension, int full_dimension, <a class="el" href="classgen__params.html">gen_params</a> *parameters, double abserr, double relerr, std::string error_log, bool logerr)</td></tr>
<tr class="memdesc:a00c44f9e3bf774c7230d972c64b81326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine that implements GSL numerical integration to calculate the Fishers &ndash; batch modifications version.  <a href="fisher_8cpp.html#a00c44f9e3bf774c7230d972c64b81326">More...</a><br /></td></tr>
<tr class="separator:a00c44f9e3bf774c7230d972c64b81326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0483f09b0c7a53ae7b65d3dff7385697"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fisher_8cpp.html#a0483f09b0c7a53ae7b65d3dff7385697">calculate_integrand_autodiff_gsl_subroutine</a> (double frequency, void *params_in)</td></tr>
<tr class="memdesc:a0483f09b0c7a53ae7b65d3dff7385697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivatives of the detector response using automatic differentiation &ndash; one frequency for gsl_integration.  <a href="fisher_8cpp.html#a0483f09b0c7a53ae7b65d3dff7385697">More...</a><br /></td></tr>
<tr class="separator:a0483f09b0c7a53ae7b65d3dff7385697"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab8feb32ace0a3f96caa05a3ebe36741c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8feb32ace0a3f96caa05a3ebe36741c">&#9670;&nbsp;</a></span>calculate_derivatives_autodiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculate_derivatives_autodiff </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; double &gt; **&#160;</td>
          <td class="paramname"><em>waveform_deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>waveform_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the derivatives of the detector response using automatic differentiation. </p>
<p>Possibly slower than the numerical derivative, but not susceptible to truncation error from finite difference</p>
<p>Higher dimensional fishers actually could be faster</p>
<p>NOTE: dimension parameter ALWAYS refers to the dimension of the fisher (ie the length of the source parameter vector), even though the derivatives are computed wrt dimension +1 or dimension + 2 &ndash; the +1(+2) are for the frequency deriv(time deriv) </p>

</div>
</div>
<a id="acae7abfd22bc80580996b8f677be9156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae7abfd22bc80580996b8f677be9156">&#9670;&nbsp;</a></span>calculate_fisher_elements_batch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculate_fisher_elements_batch </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>full_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; double &gt; **&#160;</td>
          <td class="paramname"><em>response_deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>psd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subroutine to calculate fisher elements for a subset of the fisher. </p>
<p>Skips elements that have dimensions (i,j) for i!=j &amp;&amp; i&gt;base_dim &amp;&amp; j&gt;base_dim</p>
<p>Sets non-computed elements to zero </p>

</div>
</div>
<a id="a0483f09b0c7a53ae7b65d3dff7385697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0483f09b0c7a53ae7b65d3dff7385697">&#9670;&nbsp;</a></span>calculate_integrand_autodiff_gsl_subroutine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double calculate_integrand_autodiff_gsl_subroutine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>params_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the derivatives of the detector response using automatic differentiation &ndash; one frequency for gsl_integration. </p>
<p>Possibly slower than the numerical derivative, but not susceptible to truncation error from finite difference</p>
<p>Higher dimensional fishers actually could be faster</p>
<p>NOTE: dimension parameter ALWAYS refers to the dimension of the fisher (ie the length of the source parameter vector), even though the derivatives are computed wrt dimension +1 or dimension + 2 &ndash; the +1(+2) are for the frequency deriv(time deriv) </p>

</div>
</div>
<a id="af071af4a0f6f8ab05c1cdc76a275cd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af071af4a0f6f8ab05c1cdc76a275cd49">&#9670;&nbsp;</a></span>detect_adjust_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void detect_adjust_parameters </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>freq_boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>grad_freqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>boundary_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>input_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust parameters for detector specific configurations (namely, LISA introduces extra transitions that needs to be accounted for) </p>
<p>This is kept separate to improve the modularity of the code. Waveform specific parameters are taken care of in prep_fisher_calculation and detector specific parameters are taken care of here. </p>

</div>
</div>
<a id="a32601e9b8b1e1e36905da85a4acc5d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32601e9b8b1e1e36905da85a4acc5d43">&#9670;&nbsp;</a></span>fisher_autodiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>amp_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>noise</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the fisher matrix for the given arguments to within numerical error using automatic differention - slower than the numerical version. </p>
<p>Build around ADOL-C &ndash; A. Walther und A. Griewank: Getting started with ADOL-C. In U. Naumann und O. Schenk, Combinatorial Scientific Computing, Chapman-Hall CRC Computational Science, pp. 181-202 (2012). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>if 0, standard frequency range for the detector is used </td></tr>
    <tr><td class="paramname">output</td><td>double [dimension][dimension] </td></tr>
    <tr><td class="paramname">amp_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
    <tr><td class="paramname">phase_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91ee1eb7de2af646ec16426c9660f7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ee1eb7de2af646ec16426c9660f7e9">&#9670;&nbsp;</a></span>fisher_autodiff_batch_mod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff_batch_mod </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>full_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>amp_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>noise</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the fisher matrix for the given arguments to within numerical error using automatic differention in `&lsquo;batch&rsquo;' mode for modifications to GR. </p>
<p>Built around ADOL-C &ndash; A. Walther und A. Griewank: Getting started with ADOL-C. In U. Naumann und O. Schenk, Combinatorial Scientific Computing, Chapman-Hall CRC Computational Science, pp. 181-202 (2012).</p>
<p>This constructs the fisher for a list of modifications in the usual way, but skips elements of the fisher that correspond to (mod, mod) elements. Specifically, it calculates all the fisher elements except (i, j ) i&gt;GR_dimension &amp;&amp; j &gt; GR_dimension &amp;&amp; i!=j.</p>
<p>To find the fisher for one of the modifications, simply remove all the other dimensions associated with the extra modifications using rm_fisher_dim in <a class="el" href="util_8h.html">util.h</a></p>
<p>!NOTE!:This routine only works as intended when GR is the injected value, that is all the betas are evaluated at 0. And since the covariances between modifications are not computed, this should only be used to look at one modification at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>if 0, standard frequency range for the detector is used </td></tr>
    <tr><td class="paramname">output</td><td>double [dimension][dimension] </td></tr>
    <tr><td class="paramname">base_dimension</td><td>GR dimensionality </td></tr>
    <tr><td class="paramname">full_dimension</td><td>Total dimension of the output fisher (ie GR_dimension + Nmod) </td></tr>
    <tr><td class="paramname">amp_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
    <tr><td class="paramname">phase_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c6379dc95a9280ff960f5ebd8eacba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6379dc95a9280ff960f5ebd8eacba0">&#9670;&nbsp;</a></span>fisher_autodiff_gsl_integration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff_gsl_integration </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine that implements GSL numerical integration to calculate the Fishers. </p>
<p>This can be faster than brute force calculations in fisher_autodiff, but that depends</p>
<p>Trade offs:</p>
<p>Every element is calculated independently, so no information is retained between elements. In the brute force calculation, there is information reused.</p>
<p>However, time can be saved by spending less time on trivial elements (identically 0 elements, etc) and better spent on complicated elements</p>
<p>Does not have a direct interpretation in terms of integration time, as the scheme is adaptative. Sampling frequency and integration time are `&lsquo;as good as they need to be&rsquo;' to calculate the fisher</p>
<p>Implements (GSL_INTEG_GAUSS15) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequency_bounds</td><td>Bounds of integration in fourier space </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>Method of waveform generation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sensitivity_curve</td><td>Sensitivity curve to be used for the PSD -- MUST BE ANALYTIC </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Output Fisher -- must be preallocated -- shape [dimension][dimension] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>Estimated error, as specified by GSL's integration -- must be preallocated -- shape [dimension][dimension] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dimension</td><td>Dimension of the Fisher </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parameters</td><td>Generation parameters specifying source parameters and waveform options </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">abserr</td><td>Target absolute error (0 if this should be ignored -- ONE type of error must be specified) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">relerr</td><td>Target relative error (0 if this should be ignored -- ONE type of error must be specified) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af62f3397f996f468b5d78780df8a3167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62f3397f996f468b5d78780df8a3167">&#9670;&nbsp;</a></span>fisher_autodiff_gsl_integration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff_gsl_integration </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relerr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>error_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>logerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine that implements GSL numerical integration to calculate the Fishers. </p>
<p>This can be faster than brute force calculations in fisher_autodiff, but that depends</p>
<p>Trade offs:</p>
<p>Every element is calculated independently, so no information is retained between elements. In the brute force calculation, there is information reused.</p>
<p>However, time can be saved by spending less time on trivial elements (identically 0 elements, etc) and better spent on complicated elements</p>
<p>Does not have a direct interpretation in terms of integration time, as the scheme is adaptative. Sampling frequency and integration time are `&lsquo;as good as they need to be&rsquo;' to calculate the fisher</p>
<p>Implements (GSL_INTEG_GAUSS15)</p>
<p>Now includes option to log error instead of ending program for certain types of errors </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequency_bounds</td><td>Bounds of integration in fourier space </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>Method of waveform generation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sensitivity_curve</td><td>Sensitivity curve to be used for the PSD -- MUST BE ANALYTIC </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Output Fisher -- must be preallocated -- shape [dimension][dimension] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>Estimated error, as specified by GSL's integration -- must be preallocated -- shape [dimension][dimension] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dimension</td><td>Dimension of the Fisher </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parameters</td><td>Generation parameters specifying source parameters and waveform options </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">abserr</td><td>Target absolute error (0 if this should be ignored -- ONE type of error must be specified) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">relerr</td><td>Target relative error (0 if this should be ignored -- ONE type of error must be specified) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">error_log</td><td>File to write non-critical error codes to (roundoff error) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">logerr</td><td>Whether or not to end program with certain error codes, or to log them and continue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51ec10cb30ab1ca997e3c501d9927c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ec10cb30ab1ca997e3c501d9927c1a">&#9670;&nbsp;</a></span>fisher_autodiff_gsl_integration_batch_mod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff_gsl_integration_batch_mod </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>full_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine that implements GSL numerical integration to calculate the Fishers &ndash; batch modifications version. </p>
<p>Calculates Fisher for multiple modifications at a time, neglecting covariance between modifications (set to 0 in Fisher)</p>
<p>Modifications MUST BE evaluated at 0 for this routine to calculate correct results</p>
<p>This can be faster than brute force calculations in fisher_autodiff, but that depends</p>
<p>Trade offs:</p>
<p>Every element is calculated independently, so no information is retained between elements. In the brute force calculation, there is information reused.</p>
<p>However, time can be saved by spending less time on trivial elements (identically 0 elements, etc) and better spent on complicated elements</p>
<p>Does not have a direct interpretation in terms of integration time, as the scheme is adaptative. Sampling frequency and integration time are `&lsquo;as good as they need to be&rsquo;' to calculate the fisher</p>
<p>Implements (GSL_INTEG_GAUSS15) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequency_bounds</td><td>Bounds of integration in fourier space </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>Method of waveform generation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sensitivity_curve</td><td>Sensitivity curve to be used for the PSD -- MUST BE ANALYTIC </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Output Fisher -- must be preallocated -- shape [full_dimension][full_dimension] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>Estimated error, as specified by GSL's integration -- must be preallocated -- shape [full_dimension][full_dimension] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">base_dimension</td><td>Dimension of base model (ie GR dimension) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">full_dimension</td><td>Full dimension (GR dimension + Nmod) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parameters</td><td>Generation parameters specifying source parameters and waveform options </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">abserr</td><td>Target absolute error (0 if this should be ignored -- ONE type of error must be specified) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">relerr</td><td>Target relative error (0 if this should be ignored -- ONE type of error must be specified) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00c44f9e3bf774c7230d972c64b81326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c44f9e3bf774c7230d972c64b81326">&#9670;&nbsp;</a></span>fisher_autodiff_gsl_integration_batch_mod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff_gsl_integration_batch_mod </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>full_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relerr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>error_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>logerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine that implements GSL numerical integration to calculate the Fishers &ndash; batch modifications version. </p>
<p>Calculates Fisher for multiple modifications at a time, neglecting covariance between modifications (set to 0 in Fisher)</p>
<p>Modifications MUST BE evaluated at 0 for this routine to calculate correct results</p>
<p>This can be faster than brute force calculations in fisher_autodiff, but that depends</p>
<p>Trade offs:</p>
<p>Every element is calculated independently, so no information is retained between elements. In the brute force calculation, there is information reused.</p>
<p>However, time can be saved by spending less time on trivial elements (identically 0 elements, etc) and better spent on complicated elements</p>
<p>Does not have a direct interpretation in terms of integration time, as the scheme is adaptative. Sampling frequency and integration time are `&lsquo;as good as they need to be&rsquo;' to calculate the fisher</p>
<p>Implements (GSL_INTEG_GAUSS15)</p>
<p>Now includes option to log error instead of ending program for certain types of errors </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequency_bounds</td><td>Bounds of integration in fourier space </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>Method of waveform generation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sensitivity_curve</td><td>Sensitivity curve to be used for the PSD -- MUST BE ANALYTIC </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Output Fisher -- must be preallocated -- shape [full_dimension][full_dimension] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>Estimated error, as specified by GSL's integration -- must be preallocated -- shape [full_dimension][full_dimension] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">base_dimension</td><td>Dimension of base model (ie GR dimension) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">full_dimension</td><td>Full dimension (GR dimension + Nmod) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parameters</td><td>Generation parameters specifying source parameters and waveform options </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">abserr</td><td>Target absolute error (0 if this should be ignored -- ONE type of error must be specified) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">relerr</td><td>Target relative error (0 if this should be ignored -- ONE type of error must be specified) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">error_log</td><td>File to write non-critical error codes to (roundoff error) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">logerr</td><td>Whether or not to end program with certain error codes, or to log them and continue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d084e6f4a371edfc51b6e2a1324d970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d084e6f4a371edfc51b6e2a1324d970">&#9670;&nbsp;</a></span>fisher_autodiff_interp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff_interp </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>downsampling_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>amp_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>noise</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the fisher matrix for the given arguments to within numerical error using automatic differention - slower than the numerical version. </p>
<p>Build around ADOL-C &ndash; A. Walther und A. Griewank: Getting started with ADOL-C. In U. Naumann und O. Schenk, Combinatorial Scientific Computing, Chapman-Hall CRC Computational Science, pp. 181-202 (2012). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>if 0, standard frequency range for the detector is used </td></tr>
    <tr><td class="paramname">output</td><td>double [dimension][dimension] </td></tr>
    <tr><td class="paramname">amp_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
    <tr><td class="paramname">phase_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9794311b4c41baa77ce1975de890115a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9794311b4c41baa77ce1975de890115a">&#9670;&nbsp;</a></span>fisher_numerical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_numerical </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>amp_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>noise</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the fisher matrix for the given arguments. </p>
<p>Utilizes numerical derivatives &ndash; non-skyaveraged supports up to 4th order finite difference (sky averaged supports second order only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>if 0, standard frequency range for the detector is used </td></tr>
    <tr><td class="paramname">output</td><td>double [dimension][dimension] </td></tr>
    <tr><td class="paramname">order</td><td>Order of the numerical derivative (2 or 4)* </td></tr>
    <tr><td class="paramname">amp_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method -- if using numerical derivatives or speed isn't that important, just set to NULL </td></tr>
    <tr><td class="paramname">phase_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad64b3163d121d715a0eaa22a039ffbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64b3163d121d715a0eaa22a039ffbe1">&#9670;&nbsp;</a></span>local_generation_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string local_generation_method </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility for mapping generation method string to one accepted by the waveform_generation routines. </p>
<p>Certain combinations of parameters are labeled by generation method strings not under the waveform_generation routines, so a transformation is needed </p>

</div>
</div>
<a id="a92eebd80a98aa7fb1872bb8700702f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92eebd80a98aa7fb1872bb8700702f77">&#9670;&nbsp;</a></span>repack_non_parameter_options()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void repack_non_parameter_options </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>waveform_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>input_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>gen_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utilitiy to transfer non-parameter options from one <a class="el" href="classgen__params.html" title="convience wrapper for the gen_params_base class">gen_params</a> structure to another. </p>
<p>If ppE waveform ALLOCATES MEMORY &ndash; MUST be deallocated </p>

</div>
</div>
<a id="ae9abf5e34ebefb45c534eacd8c6d408b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9abf5e34ebefb45c534eacd8c6d408b">&#9670;&nbsp;</a></span>repack_parameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void repack_parameters </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>avec_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>a_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>original_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repack the parameters from an adouble vector to a gen_params_base&lt;adouble&gt; object and freqeuncy. </p>
<p>This is one of the places where the generation-method/dimension/sky_average specific modifications should go </p>

</div>
</div>
<a id="ae6b5ad58c5308a1311a93a58f2169e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b5ad58c5308a1311a93a58f2169e40">&#9670;&nbsp;</a></span>time_phase_corrected_derivative_autodiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void time_phase_corrected_derivative_autodiff </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correct_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase. </p>
<p>If specific derivatives need to taken, take this routine as a template and write it yourself.</p>
<p>The dt array has shape [dimension+1][length] (dimension + 1 for the frequency derivative, so dimension should only include the source parameters) </p>

</div>
</div>
<a id="ab3566a9d2c5776b7769f1452bf3f80f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3566a9d2c5776b7769f1452bf3f80f3">&#9670;&nbsp;</a></span>time_phase_corrected_derivative_autodiff_full_hess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void time_phase_corrected_derivative_autodiff_full_hess </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correct_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase. </p>
<p>If specific derivatives need to taken, take this routine as a template and write it yourself.</p>
<p>The dt array has shape [dimension+1][length] (dimension + 1 for the frequency derivative, so dimension should only include the source parameters) </p>

</div>
</div>
<a id="a98ccb5fbfa7dde9dc8d7fb1f38ef5e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ccb5fbfa7dde9dc8d7fb1f38ef5e16">&#9670;&nbsp;</a></span>time_phase_corrected_derivative_autodiff_numerical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void time_phase_corrected_derivative_autodiff_numerical </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correct_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase. </p>
<p>If specific derivatives need to taken, take this routine as a template and write it yourself.</p>
<p>The dt array has shape [dimension+1][length] (dimension + 1 for the frequency derivative, so dimension should only include the source parameters)</p>
<p>This takes the autodiff derivative wrt source parameters, and a numerical derivative for the frequency </p>

</div>
</div>
<a id="a093a18b5f2d85ddd1cd37cc22137ae92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093a18b5f2d85ddd1cd37cc22137ae92">&#9670;&nbsp;</a></span>time_phase_corrected_derivative_autodiff_sparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void time_phase_corrected_derivative_autodiff_sparse </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correct_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase. </p>
<p>If specific derivatives need to taken, take this routine as a template and write it yourself.</p>
<p>The dt array has shape [dimension+1][length] (dimension + 1 for the frequency derivative, so dimension should only include the source parameters) </p>

</div>
</div>
<a id="a430217adb3e9baf50041ab7fbbd9b2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430217adb3e9baf50041ab7fbbd9b2b9">&#9670;&nbsp;</a></span>time_phase_corrected_derivative_numerical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void time_phase_corrected_derivative_numerical </td>
          <td>(</td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correct_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase &ndash; numerical. </p>
<p>IN PROGRESS &ndash; DO NOT USE</p>
<p>If specific derivatives need to taken, take this routine as a template and write it yourself.</p>
<p>The dt array has shape [dimension+1][length] (dimension + 1 for the frequency derivative, so dimension should only include the (full) source parameters) </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
