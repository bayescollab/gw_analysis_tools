<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GW Analysis Tools: /home/sperkins/git-repos/gw_analysis_tools/src/fisher.cpp File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GW Analysis Tools
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_43e0a1f539e00dcfa1a6bc4d4fee4fc2.html">home</a></li><li class="navelem"><a class="el" href="../../dir_05763022fa33e3065e9809939cf9166c.html">sperkins</a></li><li class="navelem"><a class="el" href="../../dir_bc1834953964e345887f25430c2e94dd.html">git-repos</a></li><li class="navelem"><a class="el" href="../../dir_e06a4dc853c92bbcc61892af6ebfd7a2.html">gw_analysis_tools</a></li><li class="navelem"><a class="el" href="../../dir_1da235ee0321c9aa3fa0bef392be1357.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fisher.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="../../d1/dbc/fisher_8h_source.html">fisher.h</a>&gt;</code><br />
<code>#include &lt;adolc/adouble.h&gt;</code><br />
<code>#include &lt;adolc/adolc.h&gt;</code><br />
<code>#include &lt;adolc/drivers/drivers.h&gt;</code><br />
<code>#include &lt;adolc/taping.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &quot;<a class="el" href="../../d8/d3c/util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../da/d7a/detector__util_8h_source.html">detector_util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d8/d9b/io__util_8h_source.html">io_util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d2/d31/IMRPhenomD_8h_source.html">IMRPhenomD.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d2/d22/IMRPhenomP_8h_source.html">IMRPhenomP.h</a>&quot;</code><br />
<code>#include &quot;ppE_utilities.h&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d4/d80/ppE__IMRPhenomD_8h_source.html">ppE_IMRPhenomD.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d1/d9a/waveform__generator_8h_source.html">waveform_generator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d8/d00/waveform__util_8h_source.html">waveform_util.h</a>&quot;</code><br />
<code>#include &lt;gsl/gsl_interp.h&gt;</code><br />
<code>#include &lt;gsl/gsl_errno.h&gt;</code><br />
<code>#include &lt;gsl/gsl_spline.h&gt;</code><br />
<code>#include &lt;gsl/gsl_integration.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for fisher.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="../../de/dee/fisher_8cpp__incl.png" border="0" usemap="#_2home_2sperkins_2git-repos_2gw__analysis__tools_2src_2fisher_8cpp" alt=""/></div>
<map name="_2home_2sperkins_2git-repos_2gw__analysis__tools_2src_2fisher_8cpp" id="_2home_2sperkins_2git-repos_2gw__analysis__tools_2src_2fisher_8cpp">
<area shape="rect" id="node2" href="../../d1/dbc/fisher_8h.html" title="fisher.h" alt="" coords="86,184,152,211"/>
<area shape="rect" id="node3" href="../../d8/d3c/util_8h.html" title="util.h" alt="" coords="872,259,923,285"/>
<area shape="rect" id="node16" href="../../da/d7a/detector__util_8h.html" title="detector_util.h" alt="" coords="227,184,331,211"/>
<area shape="rect" id="node17" href="../../d8/d9b/io__util_8h.html" title="io_util.h" alt="" coords="35,259,102,285"/>
<area shape="rect" id="node19" href="../../d2/d31/IMRPhenomD_8h.html" title="IMRPhenomD.h" alt="" coords="796,184,912,211"/>
<area shape="rect" id="node21" href="../../d2/d22/IMRPhenomP_8h.html" title="IMRPhenomP.h" alt="" coords="759,109,874,136"/>
<area shape="rect" id="node22" href="../../d0/d96/ppE__utilities_8h_source.html" title="ppE_utilities.h" alt="" coords="1119,109,1223,136"/>
<area shape="rect" id="node24" href="../../d4/d80/ppE__IMRPhenomD_8h.html" title="ppE_IMRPhenomD.h" alt="" coords="898,109,1044,136"/>
<area shape="rect" id="node25" href="../../d1/d9a/waveform__generator_8h.html" title="waveform_generator.h" alt="" coords="356,184,506,211"/>
<area shape="rect" id="node26" href="../../d8/d00/waveform__util_8h.html" title="waveform_util.h" alt="" coords="519,109,634,136"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adc1758e3f1341295e2df1b3a82f80094"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#adc1758e3f1341295e2df1b3a82f80094">fisher_numerical</a> (double *frequency, int length, string generation_method, string detector, string reference_detector, double **output, int dimension, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *parameters, int order, int *amp_tapes, int *phase_tapes, double *noise)</td></tr>
<tr class="memdesc:adc1758e3f1341295e2df1b3a82f80094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the fisher matrix for the given arguments.  <a href="#adc1758e3f1341295e2df1b3a82f80094">More...</a><br /></td></tr>
<tr class="separator:adc1758e3f1341295e2df1b3a82f80094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d646ad4dd21d74ed91df1080f5c61c7"><td class="memItemLeft" align="right" valign="top"><a id="a8d646ad4dd21d74ed91df1080f5c61c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_derivatives</b> (std::complex&lt; double &gt; **response_deriv, double *frequencies, int length, int dimension, string detector, string reference_detector, string gen_method, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *parameters, int order)</td></tr>
<tr class="separator:a8d646ad4dd21d74ed91df1080f5c61c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b12081077e6f02d55f20d0589bc57b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#aa6b12081077e6f02d55f20d0589bc57b">fisher_autodiff_batch_mod</a> (double *frequency, int length, std::string generation_method, std::string detector, std::string reference_detector, double **output, int base_dimension, int full_dimension, <a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *parameters, std::string integration_method, double *weights, bool log10_f, double *noise, int *amp_tapes, int *phase_tapes)</td></tr>
<tr class="memdesc:aa6b12081077e6f02d55f20d0589bc57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the fisher matrix for the given arguments to within numerical error using automatic differention in ``batch'' mode for modifications to GR.  <a href="#aa6b12081077e6f02d55f20d0589bc57b">More...</a><br /></td></tr>
<tr class="separator:aa6b12081077e6f02d55f20d0589bc57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb37ba52acaf206b2887f4686eb6e5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#a2fb37ba52acaf206b2887f4686eb6e5a">fisher_autodiff_interp</a> (double *frequency, int length, std::string generation_method, std::string detector, std::string reference_detector, double **output, int dimension, <a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *parameters, int downsampling_factor, int *amp_tapes, int *phase_tapes, double *noise)</td></tr>
<tr class="memdesc:a2fb37ba52acaf206b2887f4686eb6e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DEPRECATED</b> Calculates the fisher matrix for the given arguments to within numerical error using automatic differention - slower than the numerical version  <a href="#a2fb37ba52acaf206b2887f4686eb6e5a">More...</a><br /></td></tr>
<tr class="separator:a2fb37ba52acaf206b2887f4686eb6e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aeb1efb93752f6690c233360dc6b03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#a01aeb1efb93752f6690c233360dc6b03">fisher_autodiff</a> (double *frequency, int length, std::string generation_method, std::string detector, std::string reference_detector, double **output, int dimension, <a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *parameters, std::string integration_method, double *weights, bool log10_f, double *noise, int *amp_tapes, int *phase_tapes)</td></tr>
<tr class="memdesc:a01aeb1efb93752f6690c233360dc6b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the fisher matrix for the given arguments to within numerical error using automatic differention - slower than the numerical version.  <a href="#a01aeb1efb93752f6690c233360dc6b03">More...</a><br /></td></tr>
<tr class="separator:a01aeb1efb93752f6690c233360dc6b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada6ef4bab65e527ed6ba7e40fbcf309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#aada6ef4bab65e527ed6ba7e40fbcf309">calculate_derivatives_autodiff</a> (double *frequency, int length, int dimension, std::string generation_method, <a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *parameters, std::complex&lt; double &gt; **waveform_deriv, int *waveform_tapes, std::string detector, bool autodiff_time_deriv, std::string reference_detector)</td></tr>
<tr class="memdesc:aada6ef4bab65e527ed6ba7e40fbcf309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivatives of the detector response using automatic differentiation.  <a href="#aada6ef4bab65e527ed6ba7e40fbcf309">More...</a><br /></td></tr>
<tr class="separator:aada6ef4bab65e527ed6ba7e40fbcf309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08ddae761a3005399569df9dd80d261"><td class="memItemLeft" align="right" valign="top"><a id="ad08ddae761a3005399569df9dd80d261"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#ad08ddae761a3005399569df9dd80d261">num_src_params</a> (int *N_src_params, std::string generation_method, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params)</td></tr>
<tr class="memdesc:ad08ddae761a3005399569df9dd80d261"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DEPRECATED</b> <br /></td></tr>
<tr class="separator:ad08ddae761a3005399569df9dd80d261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada801108b3d850efe063d91c2d43176"><td class="memItemLeft" align="right" valign="top"><a id="aada801108b3d850efe063d91c2d43176"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#aada801108b3d850efe063d91c2d43176">reduce_extrinsic</a> (int *src_params, int N_src_params, std::string generation_method, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params)</td></tr>
<tr class="memdesc:aada801108b3d850efe063d91c2d43176"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DEPRECATED</b> <br /></td></tr>
<tr class="separator:aada801108b3d850efe063d91c2d43176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ccb5fbfa7dde9dc8d7fb1f38ef5e16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#a98ccb5fbfa7dde9dc8d7fb1f38ef5e16">time_phase_corrected_derivative_autodiff_numerical</a> (double **dt, int length, double *frequencies, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, int dimension, bool correct_time)</td></tr>
<tr class="memdesc:a98ccb5fbfa7dde9dc8d7fb1f38ef5e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase.  <a href="#a98ccb5fbfa7dde9dc8d7fb1f38ef5e16">More...</a><br /></td></tr>
<tr class="separator:a98ccb5fbfa7dde9dc8d7fb1f38ef5e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b5ad58c5308a1311a93a58f2169e40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#ae6b5ad58c5308a1311a93a58f2169e40">time_phase_corrected_derivative_autodiff</a> (double **dt, int length, double *frequencies, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, int dimension, bool correct_time)</td></tr>
<tr class="memdesc:ae6b5ad58c5308a1311a93a58f2169e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase.  <a href="#ae6b5ad58c5308a1311a93a58f2169e40">More...</a><br /></td></tr>
<tr class="separator:ae6b5ad58c5308a1311a93a58f2169e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3566a9d2c5776b7769f1452bf3f80f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#ab3566a9d2c5776b7769f1452bf3f80f3">time_phase_corrected_derivative_autodiff_full_hess</a> (double **dt, int length, double *frequencies, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, int dimension, bool correct_time)</td></tr>
<tr class="memdesc:ab3566a9d2c5776b7769f1452bf3f80f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase.  <a href="#ab3566a9d2c5776b7769f1452bf3f80f3">More...</a><br /></td></tr>
<tr class="separator:ab3566a9d2c5776b7769f1452bf3f80f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430217adb3e9baf50041ab7fbbd9b2b9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a430217adb3e9baf50041ab7fbbd9b2b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#a430217adb3e9baf50041ab7fbbd9b2b9">time_phase_corrected_derivative_numerical</a> (T **dt, int length, T *frequencies, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; T &gt; *params, std::string generation_method, int dimension, bool correct_time)</td></tr>
<tr class="memdesc:a430217adb3e9baf50041ab7fbbd9b2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase &ndash; numerical.  <a href="#a430217adb3e9baf50041ab7fbbd9b2b9">More...</a><br /></td></tr>
<tr class="separator:a430217adb3e9baf50041ab7fbbd9b2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46b2d580bf50b5de9c7eb8bf9d361d1"><td class="memItemLeft" align="right" valign="top"><a id="ad46b2d580bf50b5de9c7eb8bf9d361d1"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>time_phase_corrected_derivative_numerical&lt; double &gt;</b> (double **, int, double *, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, std::string, int, bool)</td></tr>
<tr class="separator:ad46b2d580bf50b5de9c7eb8bf9d361d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64b3163d121d715a0eaa22a039ffbe1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#ad64b3163d121d715a0eaa22a039ffbe1">local_generation_method</a> (std::string generation_method)</td></tr>
<tr class="memdesc:ad64b3163d121d715a0eaa22a039ffbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for mapping generation method string to one accepted by the waveform_generation routines.  <a href="#ad64b3163d121d715a0eaa22a039ffbe1">More...</a><br /></td></tr>
<tr class="separator:ad64b3163d121d715a0eaa22a039ffbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af071af4a0f6f8ab05c1cdc76a275cd49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#af071af4a0f6f8ab05c1cdc76a275cd49">detect_adjust_parameters</a> (double *freq_boundaries, double *grad_freqs, int *boundary_num, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *input_params, std::string generation_method, std::string detector, int dim)</td></tr>
<tr class="memdesc:af071af4a0f6f8ab05c1cdc76a275cd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust parameters for detector specific configurations (namely, LISA introduces extra transitions that needs to be accounted for)  <a href="#af071af4a0f6f8ab05c1cdc76a275cd49">More...</a><br /></td></tr>
<tr class="separator:af071af4a0f6f8ab05c1cdc76a275cd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc06575e6f7b404a56d9c5fa8041ddf5"><td class="memItemLeft" align="right" valign="top"><a id="abc06575e6f7b404a56d9c5fa8041ddf5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#abc06575e6f7b404a56d9c5fa8041ddf5">unpack_parameters</a> (double *parameters, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *input_params, std::string generation_method, int dimension, bool *log_factors)</td></tr>
<tr class="memdesc:abc06575e6f7b404a56d9c5fa8041ddf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks the input <a class="el" href="../../d6/d3e/classgen__params.html" title="convience wrapper for the gen_params_base class ">gen_params</a> object into a double array for use with the fisher routines. <br /></td></tr>
<tr class="separator:abc06575e6f7b404a56d9c5fa8041ddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9abf5e34ebefb45c534eacd8c6d408b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae9abf5e34ebefb45c534eacd8c6d408b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#ae9abf5e34ebefb45c534eacd8c6d408b">repack_parameters</a> (T *avec_parameters, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; T &gt; *a_params, std::string generation_method, int dim, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *original_params)</td></tr>
<tr class="memdesc:ae9abf5e34ebefb45c534eacd8c6d408b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repack the parameters from an adouble vector to a gen_params_base&lt;adouble&gt; object and freqeuncy.  <a href="#ae9abf5e34ebefb45c534eacd8c6d408b">More...</a><br /></td></tr>
<tr class="separator:ae9abf5e34ebefb45c534eacd8c6d408b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92eebd80a98aa7fb1872bb8700702f77"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a92eebd80a98aa7fb1872bb8700702f77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#a92eebd80a98aa7fb1872bb8700702f77">repack_non_parameter_options</a> (<a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; T &gt; *waveform_params, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *input_params, std::string gen_method)</td></tr>
<tr class="memdesc:a92eebd80a98aa7fb1872bb8700702f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilitiy to transfer non-parameter options from one <a class="el" href="../../d6/d3e/classgen__params.html" title="convience wrapper for the gen_params_base class ">gen_params</a> structure to another.  <a href="#a92eebd80a98aa7fb1872bb8700702f77">More...</a><br /></td></tr>
<tr class="separator:a92eebd80a98aa7fb1872bb8700702f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcafe56ca448601bb2b04f5228181742"><td class="memItemLeft" align="right" valign="top"><a id="adcafe56ca448601bb2b04f5228181742"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>repack_non_parameter_options&lt; double &gt;</b> (<a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, std::string)</td></tr>
<tr class="separator:adcafe56ca448601bb2b04f5228181742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1145b36a382264d5a39f79facf8f9be"><td class="memItemLeft" align="right" valign="top"><a id="ab1145b36a382264d5a39f79facf8f9be"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>repack_non_parameter_options&lt; adouble &gt;</b> (<a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; adouble &gt; *, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, std::string)</td></tr>
<tr class="separator:ab1145b36a382264d5a39f79facf8f9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf636e94d93a8afa6e1849af23147f11"><td class="memTemplParams" colspan="2"><a id="aaf636e94d93a8afa6e1849af23147f11"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aaf636e94d93a8afa6e1849af23147f11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deallocate_non_param_options</b> (<a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; T &gt; *waveform_params, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *input_params, std::string gen_method)</td></tr>
<tr class="separator:aaf636e94d93a8afa6e1849af23147f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e9b01d2120925528a0152d1d1de598"><td class="memItemLeft" align="right" valign="top"><a id="a40e9b01d2120925528a0152d1d1de598"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate_non_param_options&lt; double &gt;</b> (<a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, std::string)</td></tr>
<tr class="separator:a40e9b01d2120925528a0152d1d1de598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a33f43298311988222599b47d4b992"><td class="memItemLeft" align="right" valign="top"><a id="ad3a33f43298311988222599b47d4b992"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate_non_param_options&lt; adouble &gt;</b> (<a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; adouble &gt; *, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, std::string)</td></tr>
<tr class="separator:ad3a33f43298311988222599b47d4b992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabed0003b88c9a4ffdc4035862219a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#adabed0003b88c9a4ffdc4035862219a4">calculate_fisher_elements_batch</a> (double *frequency, int length, int base_dimension, int full_dimension, std::complex&lt; double &gt; **response_deriv, double **output, double *psd, std::string integration_method, double *weights, bool log10_f)</td></tr>
<tr class="memdesc:adabed0003b88c9a4ffdc4035862219a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subroutine to calculate fisher elements for a subset of the fisher.  <a href="#adabed0003b88c9a4ffdc4035862219a4">More...</a><br /></td></tr>
<tr class="separator:adabed0003b88c9a4ffdc4035862219a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e1f85b3af98f868772ea95d47d33c0"><td class="memItemLeft" align="right" valign="top"><a id="ad1e1f85b3af98f868772ea95d47d33c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_fisher_elements</b> (double *frequency, int length, int dimension, std::complex&lt; double &gt; **response_deriv, double **output, double *psd, std::string integration_method, double *weights, bool log10_f)</td></tr>
<tr class="separator:ad1e1f85b3af98f868772ea95d47d33c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35526714c92028b3083eee115558984a"><td class="memItemLeft" align="right" valign="top"><a id="a35526714c92028b3083eee115558984a"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>repack_parameters&lt; adouble &gt;</b> (adouble *, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; adouble &gt; *, std::string, int, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *)</td></tr>
<tr class="separator:a35526714c92028b3083eee115558984a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339139bedbb1eb4a31f068d0e635bc8a"><td class="memItemLeft" align="right" valign="top"><a id="a339139bedbb1eb4a31f068d0e635bc8a"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>repack_parameters&lt; double &gt;</b> (double *, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *, std::string, int, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *)</td></tr>
<tr class="separator:a339139bedbb1eb4a31f068d0e635bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06005d743a31e704ea51c2e1b2f7d69b"><td class="memItemLeft" align="right" valign="top"><a id="a06005d743a31e704ea51c2e1b2f7d69b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prep_gsl_subroutine</b> (<a class="el" href="../../d9/d9b/structgsl__subroutine.html">gsl_subroutine</a> *params_packed)</td></tr>
<tr class="separator:a06005d743a31e704ea51c2e1b2f7d69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8560e6f0a861ee30845613592e70b7c"><td class="memItemLeft" align="right" valign="top"><a id="ae8560e6f0a861ee30845613592e70b7c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tape_phase_gsl_subroutine</b> (<a class="el" href="../../d9/d9b/structgsl__subroutine.html">gsl_subroutine</a> *params_packed)</td></tr>
<tr class="separator:ae8560e6f0a861ee30845613592e70b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447ef9a0bb4954bab835f418932ce61d"><td class="memItemLeft" align="right" valign="top"><a id="a447ef9a0bb4954bab835f418932ce61d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tape_time_gsl_subroutine</b> (<a class="el" href="../../d9/d9b/structgsl__subroutine.html">gsl_subroutine</a> *params_packed)</td></tr>
<tr class="separator:a447ef9a0bb4954bab835f418932ce61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76283082e8f4a45365dda6c58f25e3f"><td class="memItemLeft" align="right" valign="top"><a id="ad76283082e8f4a45365dda6c58f25e3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tape_waveform_gsl_subroutine</b> (<a class="el" href="../../d9/d9b/structgsl__subroutine.html">gsl_subroutine</a> *params_packed)</td></tr>
<tr class="separator:ad76283082e8f4a45365dda6c58f25e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23818b708bd1961b9d9ed4ee12f2a0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#ae23818b708bd1961b9d9ed4ee12f2a0e">fisher_autodiff_gsl_integration</a> (double *frequency_bounds, string generation_method, string sensitivity_curve, string detector, string reference_detector, double **output, double **error, int dimension, <a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *parameters, double abserr, double relerr)</td></tr>
<tr class="memdesc:ae23818b708bd1961b9d9ed4ee12f2a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine that implements GSL numerical integration to calculate the Fishers.  <a href="#ae23818b708bd1961b9d9ed4ee12f2a0e">More...</a><br /></td></tr>
<tr class="separator:ae23818b708bd1961b9d9ed4ee12f2a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3fac58dae5d96f60549e6633287998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#ace3fac58dae5d96f60549e6633287998">fisher_autodiff_gsl_integration</a> (double *frequency_bounds, string generation_method, string sensitivity_curve, string detector, string reference_detector, double **output, double **error, int dimension, <a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *parameters, double abserr, double relerr, std::string error_log, bool logerr)</td></tr>
<tr class="memdesc:ace3fac58dae5d96f60549e6633287998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine that implements GSL numerical integration to calculate the Fishers.  <a href="#ace3fac58dae5d96f60549e6633287998">More...</a><br /></td></tr>
<tr class="separator:ace3fac58dae5d96f60549e6633287998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727aa66ee384240bfb2e4a468ead9aee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#a727aa66ee384240bfb2e4a468ead9aee">fisher_autodiff_gsl_integration_batch_mod</a> (double *frequency_bounds, string generation_method, string sensitivity_curve, string detector, string reference_detector, double **output, double **error, int base_dimension, int full_dimension, <a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *parameters, double abserr, double relerr)</td></tr>
<tr class="memdesc:a727aa66ee384240bfb2e4a468ead9aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine that implements GSL numerical integration to calculate the Fishers &ndash; batch modifications version.  <a href="#a727aa66ee384240bfb2e4a468ead9aee">More...</a><br /></td></tr>
<tr class="separator:a727aa66ee384240bfb2e4a468ead9aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ad894f2812dba4ff39a142c66210d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#ae4ad894f2812dba4ff39a142c66210d9">fisher_autodiff_gsl_integration_batch_mod</a> (double *frequency_bounds, string generation_method, string sensitivity_curve, string detector, string reference_detector, double **output, double **error, int base_dimension, int full_dimension, <a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *parameters, double abserr, double relerr, std::string error_log, bool logerr)</td></tr>
<tr class="memdesc:ae4ad894f2812dba4ff39a142c66210d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine that implements GSL numerical integration to calculate the Fishers &ndash; batch modifications version.  <a href="#ae4ad894f2812dba4ff39a142c66210d9">More...</a><br /></td></tr>
<tr class="separator:ae4ad894f2812dba4ff39a142c66210d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0483f09b0c7a53ae7b65d3dff7385697"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#a0483f09b0c7a53ae7b65d3dff7385697">calculate_integrand_autodiff_gsl_subroutine</a> (double frequency, void *params_in)</td></tr>
<tr class="memdesc:a0483f09b0c7a53ae7b65d3dff7385697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivatives of the detector response using automatic differentiation &ndash; one frequency for gsl_integration.  <a href="#a0483f09b0c7a53ae7b65d3dff7385697">More...</a><br /></td></tr>
<tr class="separator:a0483f09b0c7a53ae7b65d3dff7385697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad903809a1b57ad4dfee52ce8384b6ebd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#ad903809a1b57ad4dfee52ce8384b6ebd">ppE_theory_transformation_calculate_derivatives</a> (std::string original_method, std::string new_method, int dimension, int base_dim, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *param, double **derivatives)</td></tr>
<tr class="memdesc:ad903809a1b57ad4dfee52ce8384b6ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the gradient of  wrt {}.  <a href="#ad903809a1b57ad4dfee52ce8384b6ebd">More...</a><br /></td></tr>
<tr class="separator:ad903809a1b57ad4dfee52ce8384b6ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17390e3cb481a816a3e619a4f3f680a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#ac17390e3cb481a816a3e619a4f3f680a">ppE_theory_transformation_jac</a> (std::string original_method, std::string new_method, int dimension, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *param, double **jac)</td></tr>
<tr class="memdesc:ac17390e3cb481a816a3e619a4f3f680a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the jacobian matrix going from ppE to a specific theory.  <a href="#ac17390e3cb481a816a3e619a4f3f680a">More...</a><br /></td></tr>
<tr class="separator:ac17390e3cb481a816a3e619a4f3f680a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b73a325268c3d52e99f93aba2aba60e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#a8b73a325268c3d52e99f93aba2aba60e">ppE_theory_fisher_transformation</a> (std::string original_method, std::string new_method, int dimension, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *param, double **old_fisher, double **new_fisher)</td></tr>
<tr class="memdesc:a8b73a325268c3d52e99f93aba2aba60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a generic ppE Fisher matrix to a theory specific Fisher matrix.  <a href="#a8b73a325268c3d52e99f93aba2aba60e">More...</a><br /></td></tr>
<tr class="separator:a8b73a325268c3d52e99f93aba2aba60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47e3de572425bad945ddd38d0dfa9d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd7/fisher_8cpp.html#ac47e3de572425bad945ddd38d0dfa9d7">ppE_theory_covariance_transformation</a> (std::string original_method, std::string new_method, int dimension, <a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *param, double **old_cov, double **new_cov)</td></tr>
<tr class="memdesc:ac47e3de572425bad945ddd38d0dfa9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a generic ppE covariance matrix to a theory specific covariance matrix.  <a href="#ac47e3de572425bad945ddd38d0dfa9d7">More...</a><br /></td></tr>
<tr class="separator:ac47e3de572425bad945ddd38d0dfa9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aada6ef4bab65e527ed6ba7e40fbcf309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada6ef4bab65e527ed6ba7e40fbcf309">&#9670;&nbsp;</a></span>calculate_derivatives_autodiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculate_derivatives_autodiff </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; double &gt; **&#160;</td>
          <td class="paramname"><em>waveform_deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>waveform_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autodiff_time_deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>reference_detector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the derivatives of the detector response using automatic differentiation. </p>
<p>Possibly slower than the numerical derivative, but not susceptible to truncation error from finite difference</p>
<p>Higher dimensional fishers actually could be faster</p>
<p>NOTE: dimension parameter ALWAYS refers to the dimension of the fisher (ie the length of the source parameter vector), even though the derivatives are computed wrt dimension +1 or dimension + 2 &ndash; the +1(+2) are for the frequency deriv(time deriv)</p>
<p>autodiff_time_deriv indicates if the time derivatives for space detectors should be done, either with the full autodiff hessian (slow) or with the numerical approximation (autodiff then numerical) </p>

</div>
</div>
<a id="adabed0003b88c9a4ffdc4035862219a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabed0003b88c9a4ffdc4035862219a4">&#9670;&nbsp;</a></span>calculate_fisher_elements_batch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculate_fisher_elements_batch </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>full_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; double &gt; **&#160;</td>
          <td class="paramname"><em>response_deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>psd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>integration_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>log10_f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subroutine to calculate fisher elements for a subset of the fisher. </p>
<p>Skips elements that have dimensions (i,j) for i!=j &amp;&amp; i&gt;base_dim &amp;&amp; j&gt;base_dim</p>
<p>Sets non-computed elements to zero </p>

</div>
</div>
<a id="a0483f09b0c7a53ae7b65d3dff7385697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0483f09b0c7a53ae7b65d3dff7385697">&#9670;&nbsp;</a></span>calculate_integrand_autodiff_gsl_subroutine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double calculate_integrand_autodiff_gsl_subroutine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>params_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the derivatives of the detector response using automatic differentiation &ndash; one frequency for gsl_integration. </p>
<p>Possibly slower than the numerical derivative, but not susceptible to truncation error from finite difference</p>
<p>Higher dimensional fishers actually could be faster</p>
<p>NOTE: dimension parameter ALWAYS refers to the dimension of the fisher (ie the length of the source parameter vector), even though the derivatives are computed wrt dimension +1 or dimension + 2 &ndash; the +1(+2) are for the frequency deriv(time deriv) </p>

</div>
</div>
<a id="af071af4a0f6f8ab05c1cdc76a275cd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af071af4a0f6f8ab05c1cdc76a275cd49">&#9670;&nbsp;</a></span>detect_adjust_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void detect_adjust_parameters </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>freq_boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>grad_freqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>boundary_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>input_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust parameters for detector specific configurations (namely, LISA introduces extra transitions that needs to be accounted for) </p>
<p>This is kept separate to improve the modularity of the code. Waveform specific parameters are taken care of in prep_fisher_calculation and detector specific parameters are taken care of here. </p>

</div>
</div>
<a id="a01aeb1efb93752f6690c233360dc6b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01aeb1efb93752f6690c233360dc6b03">&#9670;&nbsp;</a></span>fisher_autodiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>reference_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>integration_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>log10_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>noise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>amp_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase_tapes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the fisher matrix for the given arguments to within numerical error using automatic differention - slower than the numerical version. </p>
<p>Build around ADOL-C &ndash; A. Walther und A. Griewank: Getting started with ADOL-C. In U. Naumann und O. Schenk, Combinatorial Scientific Computing, Chapman-Hall CRC Computational Science, pp. 181-202 (2012).</p>
<p>Note: If trying to run large number of Fishers concurrently with openmp, you may need to change some ADOL-C parameters. Copy the example .adolcrc file in data/ to the working directory and adjust as needed</p>
<p>If integration method is gaussian quadrature and the frequencies are !NULL, the weights must be pre-allocated.</p>
<p>If the integration method is Newton-Cotes, the weights are not used.</p>
<p>Integration schemes:</p>
<p>Newton-Cotes methods: </p><pre class="fragment">SIMPSONS
</pre><p>Gaussian Quadrature </p><pre class="fragment">GAUSSLEG
</pre><p>log10_f used if frequencies are logarithmically (base 10) spaced. NOTE: not sure if this would work for SIMPSONS &ndash; this hasn't been tested. For now, only gaussian quadrature routines are supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>if 0, standard frequency range for the detector is used </td></tr>
    <tr><td class="paramname">output</td><td>double [dimension][dimension] </td></tr>
    <tr><td class="paramname">dimension</td><td>dimension of the fisher </td></tr>
    <tr><td class="paramname">parameters</td><td>Injection parameters </td></tr>
    <tr><td class="paramname">integration_method</td><td>Method of integration to use </td></tr>
    <tr><td class="paramname">weights</td><td>If using a gaussian quadrature method and the weights have been precomputed, the weights can be supplied here </td></tr>
    <tr><td class="paramname">log10_f</td><td>Boolean for logarithmically (base 10) spaced frequencies </td></tr>
    <tr><td class="paramname">noise</td><td>Precomputed PSD array </td></tr>
    <tr><td class="paramname">amp_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
    <tr><td class="paramname">phase_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6b12081077e6f02d55f20d0589bc57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b12081077e6f02d55f20d0589bc57b">&#9670;&nbsp;</a></span>fisher_autodiff_batch_mod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff_batch_mod </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>reference_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>full_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>integration_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>log10_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>noise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>amp_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase_tapes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the fisher matrix for the given arguments to within numerical error using automatic differention in ``batch'' mode for modifications to GR. </p>
<p>Built around ADOL-C &ndash; A. Walther und A. Griewank: Getting started with ADOL-C. In U. Naumann und O. Schenk, Combinatorial Scientific Computing, Chapman-Hall CRC Computational Science, pp. 181-202 (2012).</p>
<p>This constructs the fisher for a list of modifications in the usual way, but skips elements of the fisher that correspond to (mod, mod) elements. Specifically, it calculates all the fisher elements except (i, j ) i&gt;GR_dimension &amp;&amp; j &gt; GR_dimension &amp;&amp; i!=j.</p>
<p>To find the fisher for one of the modifications, simply remove all the other dimensions associated with the extra modifications using rm_fisher_dim in <a class="el" href="../../d8/d3c/util_8h.html">util.h</a></p>
<p>!NOTE!:This routine only works as intended when GR is the injected value, ie, all the betas are evaluated at 0. And since the covariances between modifications are not computed, this should only be used to look at one modification at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>if 0, standard frequency range for the detector is used </td></tr>
    <tr><td class="paramname">output</td><td>double [dimension][dimension] </td></tr>
    <tr><td class="paramname">base_dimension</td><td>GR dimensionality </td></tr>
    <tr><td class="paramname">full_dimension</td><td>Total dimension of the output fisher (ie GR_dimension + Nmod) </td></tr>
    <tr><td class="paramname">integration_method</td><td>Method of integration to use </td></tr>
    <tr><td class="paramname">weights</td><td>If using a gaussian quadrature method and the weights have been precomputed, the weights can be supplied here </td></tr>
    <tr><td class="paramname">log10_f</td><td>Boolean for logarithmically (base 10) spaced frequencies </td></tr>
    <tr><td class="paramname">noise</td><td>Precomputed PSD array </td></tr>
    <tr><td class="paramname">amp_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
    <tr><td class="paramname">phase_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae23818b708bd1961b9d9ed4ee12f2a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23818b708bd1961b9d9ed4ee12f2a0e">&#9670;&nbsp;</a></span>fisher_autodiff_gsl_integration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff_gsl_integration </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>reference_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine that implements GSL numerical integration to calculate the Fishers. </p>
<p>This can be faster than brute force calculations in fisher_autodiff, but that depends</p>
<p>Trade offs:</p>
<p>Every element is calculated independently, so no information is retained between elements. In the brute force calculation, there is information reused.</p>
<p>However, time can be saved by spending less time on trivial elements (identically 0 elements, etc) and better spent on complicated elements</p>
<p>Does not have a direct interpretation in terms of integration time, as the scheme is adaptative. Sampling frequency and integration time are ``as good as they need to be'' to calculate the fisher</p>
<p>Implements (GSL_INTEG_GAUSS15) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequency_bounds</td><td>Bounds of integration in fourier space </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>Method of waveform generation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sensitivity_curve</td><td>Sensitivity curve to be used for the PSD &ndash; MUST BE ANALYTIC </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">reference_detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Output Fisher &ndash; must be preallocated &ndash; shape [dimension][dimension] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>Estimated error, as specified by GSL's integration &ndash; must be preallocated &ndash; shape [dimension][dimension] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dimension</td><td>Dimension of the Fisher </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parameters</td><td>Generation parameters specifying source parameters and waveform options </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">abserr</td><td>Target absolute error (0 if this should be ignored &ndash; ONE type of error must be specified) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">relerr</td><td>Target relative error (0 if this should be ignored &ndash; ONE type of error must be specified) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace3fac58dae5d96f60549e6633287998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3fac58dae5d96f60549e6633287998">&#9670;&nbsp;</a></span>fisher_autodiff_gsl_integration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff_gsl_integration </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>reference_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relerr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>error_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>logerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine that implements GSL numerical integration to calculate the Fishers. </p>
<p>This can be faster than brute force calculations in fisher_autodiff, but that depends</p>
<p>Trade offs:</p>
<p>Every element is calculated independently, so no information is retained between elements. In the brute force calculation, there is information reused.</p>
<p>However, time can be saved by spending less time on trivial elements (identically 0 elements, etc) and better spent on complicated elements</p>
<p>Does not have a direct interpretation in terms of integration time, as the scheme is adaptative. Sampling frequency and integration time are ``as good as they need to be'' to calculate the fisher</p>
<p>Implements (GSL_INTEG_GAUSS15)</p>
<p>Now includes option to log error instead of ending program for certain types of errors </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequency_bounds</td><td>Bounds of integration in fourier space </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>Method of waveform generation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sensitivity_curve</td><td>Sensitivity curve to be used for the PSD &ndash; MUST BE ANALYTIC </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">reference_detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Output Fisher &ndash; must be preallocated &ndash; shape [dimension][dimension] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>Estimated error, as specified by GSL's integration &ndash; must be preallocated &ndash; shape [dimension][dimension] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dimension</td><td>Dimension of the Fisher </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parameters</td><td>Generation parameters specifying source parameters and waveform options </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">abserr</td><td>Target absolute error (0 if this should be ignored &ndash; ONE type of error must be specified) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">relerr</td><td>Target relative error (0 if this should be ignored &ndash; ONE type of error must be specified) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">error_log</td><td>File to write non-critical error codes to (roundoff error) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">logerr</td><td>Whether or not to end program with certain error codes, or to log them and continue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a727aa66ee384240bfb2e4a468ead9aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727aa66ee384240bfb2e4a468ead9aee">&#9670;&nbsp;</a></span>fisher_autodiff_gsl_integration_batch_mod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff_gsl_integration_batch_mod </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>reference_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>full_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine that implements GSL numerical integration to calculate the Fishers &ndash; batch modifications version. </p>
<p>Calculates Fisher for multiple modifications at a time, neglecting covariance between modifications (set to 0 in Fisher)</p>
<p>Modifications MUST BE evaluated at 0 for this routine to calculate correct results</p>
<p>This can be faster than brute force calculations in fisher_autodiff, but that depends</p>
<p>Trade offs:</p>
<p>Every element is calculated independently, so no information is retained between elements. In the brute force calculation, there is information reused.</p>
<p>However, time can be saved by spending less time on trivial elements (identically 0 elements, etc) and better spent on complicated elements</p>
<p>Does not have a direct interpretation in terms of integration time, as the scheme is adaptative. Sampling frequency and integration time are ``as good as they need to be'' to calculate the fisher</p>
<p>Implements (GSL_INTEG_GAUSS15) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequency_bounds</td><td>Bounds of integration in fourier space </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>Method of waveform generation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sensitivity_curve</td><td>Sensitivity curve to be used for the PSD &ndash; MUST BE ANALYTIC </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">reference_detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Output Fisher &ndash; must be preallocated &ndash; shape [full_dimension][full_dimension] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>Estimated error, as specified by GSL's integration &ndash; must be preallocated &ndash; shape [full_dimension][full_dimension] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">base_dimension</td><td>Dimension of base model (ie GR dimension) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">full_dimension</td><td>Full dimension (GR dimension + Nmod) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parameters</td><td>Generation parameters specifying source parameters and waveform options </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">abserr</td><td>Target absolute error (0 if this should be ignored &ndash; ONE type of error must be specified) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">relerr</td><td>Target relative error (0 if this should be ignored &ndash; ONE type of error must be specified) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4ad894f2812dba4ff39a142c66210d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ad894f2812dba4ff39a142c66210d9">&#9670;&nbsp;</a></span>fisher_autodiff_gsl_integration_batch_mod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff_gsl_integration_batch_mod </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>reference_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>full_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relerr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>error_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>logerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine that implements GSL numerical integration to calculate the Fishers &ndash; batch modifications version. </p>
<p>Calculates Fisher for multiple modifications at a time, neglecting covariance between modifications (set to 0 in Fisher)</p>
<p>Modifications MUST BE evaluated at 0 for this routine to calculate correct results</p>
<p>This can be faster than brute force calculations in fisher_autodiff, but that depends</p>
<p>Trade offs:</p>
<p>Every element is calculated independently, so no information is retained between elements. In the brute force calculation, there is information reused.</p>
<p>However, time can be saved by spending less time on trivial elements (identically 0 elements, etc) and better spent on complicated elements</p>
<p>Does not have a direct interpretation in terms of integration time, as the scheme is adaptative. Sampling frequency and integration time are ``as good as they need to be'' to calculate the fisher</p>
<p>Implements (GSL_INTEG_GAUSS15)</p>
<p>Now includes option to log error instead of ending program for certain types of errors </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequency_bounds</td><td>Bounds of integration in fourier space </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>Method of waveform generation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sensitivity_curve</td><td>Sensitivity curve to be used for the PSD &ndash; MUST BE ANALYTIC </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">reference_detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Output Fisher &ndash; must be preallocated &ndash; shape [full_dimension][full_dimension] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>Estimated error, as specified by GSL's integration &ndash; must be preallocated &ndash; shape [full_dimension][full_dimension] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">base_dimension</td><td>Dimension of base model (ie GR dimension) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">full_dimension</td><td>Full dimension (GR dimension + Nmod) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parameters</td><td>Generation parameters specifying source parameters and waveform options </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">abserr</td><td>Target absolute error (0 if this should be ignored &ndash; ONE type of error must be specified) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">relerr</td><td>Target relative error (0 if this should be ignored &ndash; ONE type of error must be specified) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">error_log</td><td>File to write non-critical error codes to (roundoff error) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">logerr</td><td>Whether or not to end program with certain error codes, or to log them and continue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fb37ba52acaf206b2887f4686eb6e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb37ba52acaf206b2887f4686eb6e5a">&#9670;&nbsp;</a></span>fisher_autodiff_interp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_autodiff_interp </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>reference_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d3e/classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>downsampling_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>amp_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>noise</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DEPRECATED</b> Calculates the fisher matrix for the given arguments to within numerical error using automatic differention - slower than the numerical version </p>
<p>Build around ADOL-C &ndash; A. Walther und A. Griewank: Getting started with ADOL-C. In U. Naumann und O. Schenk, Combinatorial Scientific Computing, Chapman-Hall CRC Computational Science, pp. 181-202 (2012).</p>
<p>Not sure what the accuracy was. Probably shouldn't be trusted </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>if 0, standard frequency range for the detector is used </td></tr>
    <tr><td class="paramname">output</td><td>double [dimension][dimension] </td></tr>
    <tr><td class="paramname">amp_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
    <tr><td class="paramname">phase_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc1758e3f1341295e2df1b3a82f80094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1758e3f1341295e2df1b3a82f80094">&#9670;&nbsp;</a></span>fisher_numerical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fisher_numerical </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>reference_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>amp_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase_tapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>noise</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the fisher matrix for the given arguments. </p>
<p>Utilizes numerical derivatives &ndash; non-skyaveraged supports up to 4th order finite difference (sky averaged supports second order only)</p>
<p>NOT SAFE FOR LISA YET &ndash; see hessian of phase for time derivative </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>if 0, standard frequency range for the detector is used </td></tr>
    <tr><td class="paramname">output</td><td>double [dimension][dimension] </td></tr>
    <tr><td class="paramname">order</td><td>Order of the numerical derivative (2 or 4)* </td></tr>
    <tr><td class="paramname">amp_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method &ndash; if using numerical derivatives or speed isn't that important, just set to NULL </td></tr>
    <tr><td class="paramname">phase_tapes</td><td>if speed is required, precomputed tapes can be used - assumed the user knows what they're doing, no checks done here to make sure that the number of tapes matches the requirement by the generation_method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad64b3163d121d715a0eaa22a039ffbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64b3163d121d715a0eaa22a039ffbe1">&#9670;&nbsp;</a></span>local_generation_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string local_generation_method </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility for mapping generation method string to one accepted by the waveform_generation routines. </p>
<p>Certain combinations of parameters are labeled by generation method strings not under the waveform_generation routines, so a transformation is needed </p>

</div>
</div>
<a id="ac47e3de572425bad945ddd38d0dfa9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47e3de572425bad945ddd38d0dfa9d7">&#9670;&nbsp;</a></span>ppE_theory_covariance_transformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ppE_theory_covariance_transformation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>original_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>new_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>old_cov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>new_cov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a generic ppE covariance matrix to a theory specific covariance matrix. </p>
<p>See ppE_utilities.cpp for a list of supported theories.</p>
<p>The covariance matrix is defined as ()^-1 where,  is the Fisher matrix </p>

</div>
</div>
<a id="a8b73a325268c3d52e99f93aba2aba60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b73a325268c3d52e99f93aba2aba60e">&#9670;&nbsp;</a></span>ppE_theory_fisher_transformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ppE_theory_fisher_transformation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>original_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>new_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>old_fisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>new_fisher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a generic ppE Fisher matrix to a theory specific Fisher matrix. </p>
<p>See ppE_utilities.cpp for a list of supported theories. </p>

</div>
</div>
<a id="ad903809a1b57ad4dfee52ce8384b6ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad903809a1b57ad4dfee52ce8384b6ebd">&#9670;&nbsp;</a></span>ppE_theory_transformation_calculate_derivatives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ppE_theory_transformation_calculate_derivatives </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>original_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>new_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>derivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the gradient of  wrt {}. </p>
<p>Computes the gradient for multiple betas, if present </p>

</div>
</div>
<a id="ac17390e3cb481a816a3e619a4f3f680a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17390e3cb481a816a3e619a4f3f680a">&#9670;&nbsp;</a></span>ppE_theory_transformation_jac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ppE_theory_transformation_jac </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>original_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>new_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>jac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the jacobian matrix going from ppE to a specific theory. </p>
<p>d  / d  where  is the ppE parameterrs, and  are the theory specific parameters </p>

</div>
</div>
<a id="a92eebd80a98aa7fb1872bb8700702f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92eebd80a98aa7fb1872bb8700702f77">&#9670;&nbsp;</a></span>repack_non_parameter_options()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void repack_non_parameter_options </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>waveform_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>input_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>gen_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utilitiy to transfer non-parameter options from one <a class="el" href="../../d6/d3e/classgen__params.html" title="convience wrapper for the gen_params_base class ">gen_params</a> structure to another. </p>
<p>If ppE waveform ALLOCATES MEMORY &ndash; MUST be deallocated </p>

</div>
</div>
<a id="ae9abf5e34ebefb45c534eacd8c6d408b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9abf5e34ebefb45c534eacd8c6d408b">&#9670;&nbsp;</a></span>repack_parameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void repack_parameters </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>avec_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>a_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>original_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repack the parameters from an adouble vector to a gen_params_base&lt;adouble&gt; object and freqeuncy. </p>
<p>This is one of the places where the generation-method/dimension/sky_average specific modifications should go </p>

</div>
</div>
<a id="ae6b5ad58c5308a1311a93a58f2169e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b5ad58c5308a1311a93a58f2169e40">&#9670;&nbsp;</a></span>time_phase_corrected_derivative_autodiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void time_phase_corrected_derivative_autodiff </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correct_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase. </p>
<p>If specific derivatives need to taken, take this routine as a template and write it yourself.</p>
<p>The dt array has shape [dimension+1][length] (dimension + 1 for the frequency derivative, so dimension should only include the source parameters) </p>

</div>
</div>
<a id="ab3566a9d2c5776b7769f1452bf3f80f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3566a9d2c5776b7769f1452bf3f80f3">&#9670;&nbsp;</a></span>time_phase_corrected_derivative_autodiff_full_hess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void time_phase_corrected_derivative_autodiff_full_hess </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correct_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase. </p>
<p>If specific derivatives need to taken, take this routine as a template and write it yourself.</p>
<p>The dt array has shape [dimension+1][length] (dimension + 1 for the frequency derivative, so dimension should only include the source parameters)</p>
<p>Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase</p>
<p>If specific derivatives need to taken, take this routine as a template and write it yourself.</p>
<p>The dt array has shape [dimension+1][length] (dimension + 1 for the frequency derivative, so dimension should only include the source parameters) </p>

</div>
</div>
<a id="a98ccb5fbfa7dde9dc8d7fb1f38ef5e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ccb5fbfa7dde9dc8d7fb1f38ef5e16">&#9670;&nbsp;</a></span>time_phase_corrected_derivative_autodiff_numerical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void time_phase_corrected_derivative_autodiff_numerical </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correct_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase. </p>
<p>If specific derivatives need to taken, take this routine as a template and write it yourself.</p>
<p>The dt array has shape [dimension+1][length] (dimension + 1 for the frequency derivative, so dimension should only include the source parameters)</p>
<p>This takes the autodiff derivative wrt source parameters, and a numerical derivative for the frequency </p>

</div>
</div>
<a id="a430217adb3e9baf50041ab7fbbd9b2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430217adb3e9baf50041ab7fbbd9b2b9">&#9670;&nbsp;</a></span>time_phase_corrected_derivative_numerical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void time_phase_corrected_derivative_numerical </td>
          <td>(</td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dea/classgen__params__base.html">gen_params_base</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correct_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the derivative of the phase w.r.t. source parameters AS DEFINED BY FISHER FILE &ndash; hessian of the phase &ndash; numerical. </p>
<p>IN PROGRESS &ndash; DO NOT USE</p>
<p>If specific derivatives need to taken, take this routine as a template and write it yourself.</p>
<p>The dt array has shape [dimension+1][length] (dimension + 1 for the frequency derivative, so dimension should only include the (full) source parameters) </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
