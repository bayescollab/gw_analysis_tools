\hypertarget{fisher_8cpp}{}\doxysection{src/fisher.cpp File Reference}
\label{fisher_8cpp}\index{src/fisher.cpp@{src/fisher.cpp}}
{\ttfamily \#include $<$fisher.\+h$>$}\newline
{\ttfamily \#include $<$adolc/adouble.\+h$>$}\newline
{\ttfamily \#include $<$adolc/adolc.\+h$>$}\newline
{\ttfamily \#include $<$adolc/drivers/drivers.\+h$>$}\newline
{\ttfamily \#include $<$adolc/taping.\+h$>$}\newline
{\ttfamily \#include $<$adolc/adolc\+\_\+sparse.\+h$>$}\newline
{\ttfamily \#include $<$math.\+h$>$}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include \char`\"{}util.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}detector\+\_\+util.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}I\+M\+R\+Phenom\+D.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}I\+M\+R\+Phenom\+P.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}pp\+E\+\_\+\+I\+M\+R\+Phenom\+D.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}waveform\+\_\+generator.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}waveform\+\_\+util.\+h\char`\"{}}\newline
{\ttfamily \#include $<$gsl/gsl\+\_\+interp.\+h$>$}\newline
{\ttfamily \#include $<$gsl/gsl\+\_\+errno.\+h$>$}\newline
{\ttfamily \#include $<$gsl/gsl\+\_\+spline.\+h$>$}\newline
{\ttfamily \#include $<$gsl/gsl\+\_\+integration.\+h$>$}\newline
{\ttfamily \#include $<$time.\+h$>$}\newline
{\ttfamily \#include $<$fstream$>$}\newline
Include dependency graph for fisher.\+cpp\+:
% FIG 0
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{fisher_8cpp_a9794311b4c41baa77ce1975de890115a}{fisher\+\_\+numerical}} (double $\ast$frequency, int length, string generation\+\_\+method, string detector, double $\ast$$\ast$output, int dimension, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$parameters, int order, int $\ast$amp\+\_\+tapes, int $\ast$phase\+\_\+tapes, double $\ast$noise)
\begin{DoxyCompactList}\small\item\em Calculates the fisher matrix for the given arguments. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{fisher_8cpp_a0e8bac46d59b2f9e40c199557b57ebd6}\label{fisher_8cpp_a0e8bac46d59b2f9e40c199557b57ebd6}} 
void {\bfseries calculate\+\_\+derivatives} (std\+::complex$<$ double $>$ $\ast$$\ast$response\+\_\+deriv, double $\ast$frequencies, int length, int dimension, string detector, string gen\+\_\+method, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$parameters, int order)
\item 
void \mbox{\hyperlink{fisher_8cpp_a91ee1eb7de2af646ec16426c9660f7e9}{fisher\+\_\+autodiff\+\_\+batch\+\_\+mod}} (double $\ast$frequency, int length, std\+::string generation\+\_\+method, std\+::string detector, double $\ast$$\ast$output, int base\+\_\+dimension, int full\+\_\+dimension, \mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$parameters, int $\ast$amp\+\_\+tapes, int $\ast$phase\+\_\+tapes, double $\ast$noise)
\begin{DoxyCompactList}\small\item\em Calculates the fisher matrix for the given arguments to within numerical error using automatic differention in \`{}`batch'\textquotesingle{} mode for modifications to GR. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{fisher_8cpp_a3d084e6f4a371edfc51b6e2a1324d970}{fisher\+\_\+autodiff\+\_\+interp}} (double $\ast$frequency, int length, std\+::string generation\+\_\+method, std\+::string detector, double $\ast$$\ast$output, int dimension, \mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$parameters, int downsampling\+\_\+factor, int $\ast$amp\+\_\+tapes, int $\ast$phase\+\_\+tapes, double $\ast$noise)
\begin{DoxyCompactList}\small\item\em Calculates the fisher matrix for the given arguments to within numerical error using automatic differention -\/ slower than the numerical version. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{fisher_8cpp_a32601e9b8b1e1e36905da85a4acc5d43}{fisher\+\_\+autodiff}} (double $\ast$frequency, int length, std\+::string generation\+\_\+method, std\+::string detector, double $\ast$$\ast$output, int dimension, \mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$parameters, int $\ast$amp\+\_\+tapes, int $\ast$phase\+\_\+tapes, double $\ast$noise)
\begin{DoxyCompactList}\small\item\em Calculates the fisher matrix for the given arguments to within numerical error using automatic differention -\/ slower than the numerical version. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{fisher_8cpp_ab8feb32ace0a3f96caa05a3ebe36741c}{calculate\+\_\+derivatives\+\_\+autodiff}} (double $\ast$frequency, int length, int dimension, std\+::string generation\+\_\+method, \mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$parameters, std\+::complex$<$ double $>$ $\ast$$\ast$waveform\+\_\+deriv, int $\ast$waveform\+\_\+tapes, std\+::string detector)
\begin{DoxyCompactList}\small\item\em Calculates the derivatives of the detector response using automatic differentiation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{fisher_8cpp_ad08ddae761a3005399569df9dd80d261}\label{fisher_8cpp_ad08ddae761a3005399569df9dd80d261}} 
void {\bfseries num\+\_\+src\+\_\+params} (int $\ast$N\+\_\+src\+\_\+params, std\+::string generation\+\_\+method, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$params)
\item 
\mbox{\Hypertarget{fisher_8cpp_aada801108b3d850efe063d91c2d43176}\label{fisher_8cpp_aada801108b3d850efe063d91c2d43176}} 
void {\bfseries reduce\+\_\+extrinsic} (int $\ast$src\+\_\+params, int N\+\_\+src\+\_\+params, std\+::string generation\+\_\+method, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$params)
\item 
void \mbox{\hyperlink{fisher_8cpp_a98ccb5fbfa7dde9dc8d7fb1f38ef5e16}{time\+\_\+phase\+\_\+corrected\+\_\+derivative\+\_\+autodiff\+\_\+numerical}} (double $\ast$$\ast$dt, int length, double $\ast$frequencies, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$params, std\+::string generation\+\_\+method, int dimension, bool correct\+\_\+time)
\begin{DoxyCompactList}\small\item\em Computes the derivative of the phase w.\+r.\+t. source parameters AS D\+E\+F\+I\+N\+ED BY F\+I\+S\+H\+ER F\+I\+LE -- hessian of the phase. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{fisher_8cpp_ae6b5ad58c5308a1311a93a58f2169e40}{time\+\_\+phase\+\_\+corrected\+\_\+derivative\+\_\+autodiff}} (double $\ast$$\ast$dt, int length, double $\ast$frequencies, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$params, std\+::string generation\+\_\+method, int dimension, bool correct\+\_\+time)
\begin{DoxyCompactList}\small\item\em Computes the derivative of the phase w.\+r.\+t. source parameters AS D\+E\+F\+I\+N\+ED BY F\+I\+S\+H\+ER F\+I\+LE -- hessian of the phase. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{fisher_8cpp_a093a18b5f2d85ddd1cd37cc22137ae92}{time\+\_\+phase\+\_\+corrected\+\_\+derivative\+\_\+autodiff\+\_\+sparse}} (double $\ast$$\ast$dt, int length, double $\ast$frequencies, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$params, std\+::string generation\+\_\+method, int dimension, bool correct\+\_\+time)
\begin{DoxyCompactList}\small\item\em Computes the derivative of the phase w.\+r.\+t. source parameters AS D\+E\+F\+I\+N\+ED BY F\+I\+S\+H\+ER F\+I\+LE -- hessian of the phase. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{fisher_8cpp_ab3566a9d2c5776b7769f1452bf3f80f3}{time\+\_\+phase\+\_\+corrected\+\_\+derivative\+\_\+autodiff\+\_\+full\+\_\+hess}} (double $\ast$$\ast$dt, int length, double $\ast$frequencies, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$params, std\+::string generation\+\_\+method, int dimension, bool correct\+\_\+time)
\begin{DoxyCompactList}\small\item\em Computes the derivative of the phase w.\+r.\+t. source parameters AS D\+E\+F\+I\+N\+ED BY F\+I\+S\+H\+ER F\+I\+LE -- hessian of the phase. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\void \mbox{\hyperlink{fisher_8cpp_a430217adb3e9baf50041ab7fbbd9b2b9}{time\+\_\+phase\+\_\+corrected\+\_\+derivative\+\_\+numerical}} (T $\ast$$\ast$dt, int length, T $\ast$frequencies, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ T $>$ $\ast$params, std\+::string generation\+\_\+method, int dimension, bool correct\+\_\+time)
\begin{DoxyCompactList}\small\item\em Computes the derivative of the phase w.\+r.\+t. source parameters AS D\+E\+F\+I\+N\+ED BY F\+I\+S\+H\+ER F\+I\+LE -- hessian of the phase -- numerical. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{fisher_8cpp_ad46b2d580bf50b5de9c7eb8bf9d361d1}\label{fisher_8cpp_ad46b2d580bf50b5de9c7eb8bf9d361d1}} 
template void {\bfseries time\+\_\+phase\+\_\+corrected\+\_\+derivative\+\_\+numerical$<$ double $>$} (double $\ast$$\ast$, int, double $\ast$, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$, std\+::string, int, bool)
\item 
std\+::string \mbox{\hyperlink{fisher_8cpp_ad64b3163d121d715a0eaa22a039ffbe1}{local\+\_\+generation\+\_\+method}} (std\+::string generation\+\_\+method)
\begin{DoxyCompactList}\small\item\em Utility for mapping generation method string to one accepted by the waveform\+\_\+generation routines. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{fisher_8cpp_af071af4a0f6f8ab05c1cdc76a275cd49}{detect\+\_\+adjust\+\_\+parameters}} (double $\ast$freq\+\_\+boundaries, double $\ast$grad\+\_\+freqs, int $\ast$boundary\+\_\+num, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$input\+\_\+params, std\+::string generation\+\_\+method, std\+::string detector, int dim)
\begin{DoxyCompactList}\small\item\em Adjust parameters for detector specific configurations (namely, L\+I\+SA introduces extra transitions that needs to be accounted for) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{fisher_8cpp_abc06575e6f7b404a56d9c5fa8041ddf5}\label{fisher_8cpp_abc06575e6f7b404a56d9c5fa8041ddf5}} 
void \mbox{\hyperlink{fisher_8cpp_abc06575e6f7b404a56d9c5fa8041ddf5}{unpack\+\_\+parameters}} (double $\ast$parameters, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$input\+\_\+params, std\+::string generation\+\_\+method, int dimension, bool $\ast$log\+\_\+factors)
\begin{DoxyCompactList}\small\item\em Unpacks the input \mbox{\hyperlink{classgen__params}{gen\+\_\+params}} object into a double array for use with the fisher routines. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\void \mbox{\hyperlink{fisher_8cpp_ae9abf5e34ebefb45c534eacd8c6d408b}{repack\+\_\+parameters}} (T $\ast$avec\+\_\+parameters, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ T $>$ $\ast$a\+\_\+params, std\+::string generation\+\_\+method, int dim, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$original\+\_\+params)
\begin{DoxyCompactList}\small\item\em Repack the parameters from an adouble vector to a gen\+\_\+params\+\_\+base$<$adouble$>$ object and freqeuncy. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\void \mbox{\hyperlink{fisher_8cpp_a92eebd80a98aa7fb1872bb8700702f77}{repack\+\_\+non\+\_\+parameter\+\_\+options}} (\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ T $>$ $\ast$waveform\+\_\+params, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$input\+\_\+params, std\+::string gen\+\_\+method)
\begin{DoxyCompactList}\small\item\em Utilitiy to transfer non-\/parameter options from one \mbox{\hyperlink{classgen__params}{gen\+\_\+params}} structure to another. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{fisher_8cpp_adcafe56ca448601bb2b04f5228181742}\label{fisher_8cpp_adcafe56ca448601bb2b04f5228181742}} 
template void {\bfseries repack\+\_\+non\+\_\+parameter\+\_\+options$<$ double $>$} (\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$, std\+::string)
\item 
\mbox{\Hypertarget{fisher_8cpp_ab1145b36a382264d5a39f79facf8f9be}\label{fisher_8cpp_ab1145b36a382264d5a39f79facf8f9be}} 
template void {\bfseries repack\+\_\+non\+\_\+parameter\+\_\+options$<$ adouble $>$} (\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ adouble $>$ $\ast$, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$, std\+::string)
\item 
\mbox{\Hypertarget{fisher_8cpp_aaf636e94d93a8afa6e1849af23147f11}\label{fisher_8cpp_aaf636e94d93a8afa6e1849af23147f11}} 
{\footnotesize template$<$class T $>$ }\\void {\bfseries deallocate\+\_\+non\+\_\+param\+\_\+options} (\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ T $>$ $\ast$waveform\+\_\+params, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$input\+\_\+params, std\+::string gen\+\_\+method)
\item 
\mbox{\Hypertarget{fisher_8cpp_a40e9b01d2120925528a0152d1d1de598}\label{fisher_8cpp_a40e9b01d2120925528a0152d1d1de598}} 
template void {\bfseries deallocate\+\_\+non\+\_\+param\+\_\+options$<$ double $>$} (\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$, std\+::string)
\item 
\mbox{\Hypertarget{fisher_8cpp_ad3a33f43298311988222599b47d4b992}\label{fisher_8cpp_ad3a33f43298311988222599b47d4b992}} 
template void {\bfseries deallocate\+\_\+non\+\_\+param\+\_\+options$<$ adouble $>$} (\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ adouble $>$ $\ast$, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$, std\+::string)
\item 
void \mbox{\hyperlink{fisher_8cpp_acae7abfd22bc80580996b8f677be9156}{calculate\+\_\+fisher\+\_\+elements\+\_\+batch}} (double $\ast$frequency, int length, int base\+\_\+dimension, int full\+\_\+dimension, std\+::complex$<$ double $>$ $\ast$$\ast$response\+\_\+deriv, double $\ast$$\ast$output, double $\ast$psd)
\begin{DoxyCompactList}\small\item\em Subroutine to calculate fisher elements for a subset of the fisher. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{fisher_8cpp_a8da03c0eee5317e59d67f85dd6358494}\label{fisher_8cpp_a8da03c0eee5317e59d67f85dd6358494}} 
void {\bfseries calculate\+\_\+fisher\+\_\+elements} (double $\ast$frequency, int length, int dimension, std\+::complex$<$ double $>$ $\ast$$\ast$response\+\_\+deriv, double $\ast$$\ast$output, double $\ast$psd)
\item 
\mbox{\Hypertarget{fisher_8cpp_a35526714c92028b3083eee115558984a}\label{fisher_8cpp_a35526714c92028b3083eee115558984a}} 
template void {\bfseries repack\+\_\+parameters$<$ adouble $>$} (adouble $\ast$, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ adouble $>$ $\ast$, std\+::string, int, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$)
\item 
\mbox{\Hypertarget{fisher_8cpp_a339139bedbb1eb4a31f068d0e635bc8a}\label{fisher_8cpp_a339139bedbb1eb4a31f068d0e635bc8a}} 
template void {\bfseries repack\+\_\+parameters$<$ double $>$} (double $\ast$, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$, std\+::string, int, \mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$)
\item 
\mbox{\Hypertarget{fisher_8cpp_a06005d743a31e704ea51c2e1b2f7d69b}\label{fisher_8cpp_a06005d743a31e704ea51c2e1b2f7d69b}} 
void {\bfseries prep\+\_\+gsl\+\_\+subroutine} (\mbox{\hyperlink{structgsl__subroutine}{gsl\+\_\+subroutine}} $\ast$params\+\_\+packed)
\item 
\mbox{\Hypertarget{fisher_8cpp_ae8560e6f0a861ee30845613592e70b7c}\label{fisher_8cpp_ae8560e6f0a861ee30845613592e70b7c}} 
void {\bfseries tape\+\_\+phase\+\_\+gsl\+\_\+subroutine} (\mbox{\hyperlink{structgsl__subroutine}{gsl\+\_\+subroutine}} $\ast$params\+\_\+packed)
\item 
\mbox{\Hypertarget{fisher_8cpp_a447ef9a0bb4954bab835f418932ce61d}\label{fisher_8cpp_a447ef9a0bb4954bab835f418932ce61d}} 
void {\bfseries tape\+\_\+time\+\_\+gsl\+\_\+subroutine} (\mbox{\hyperlink{structgsl__subroutine}{gsl\+\_\+subroutine}} $\ast$params\+\_\+packed)
\item 
\mbox{\Hypertarget{fisher_8cpp_ad76283082e8f4a45365dda6c58f25e3f}\label{fisher_8cpp_ad76283082e8f4a45365dda6c58f25e3f}} 
void {\bfseries tape\+\_\+waveform\+\_\+gsl\+\_\+subroutine} (\mbox{\hyperlink{structgsl__subroutine}{gsl\+\_\+subroutine}} $\ast$params\+\_\+packed)
\item 
void \mbox{\hyperlink{fisher_8cpp_a0c6379dc95a9280ff960f5ebd8eacba0}{fisher\+\_\+autodiff\+\_\+gsl\+\_\+integration}} (double $\ast$frequency\+\_\+bounds, string generation\+\_\+method, string sensitivity\+\_\+curve, string detector, double $\ast$$\ast$output, double $\ast$$\ast$error, int dimension, \mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$parameters, double abserr, double relerr)
\begin{DoxyCompactList}\small\item\em Routine that implements G\+SL numerical integration to calculate the Fishers. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{fisher_8cpp_af62f3397f996f468b5d78780df8a3167}{fisher\+\_\+autodiff\+\_\+gsl\+\_\+integration}} (double $\ast$frequency\+\_\+bounds, string generation\+\_\+method, string sensitivity\+\_\+curve, string detector, double $\ast$$\ast$output, double $\ast$$\ast$error, int dimension, \mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$parameters, double abserr, double relerr, std\+::string error\+\_\+log, bool logerr)
\begin{DoxyCompactList}\small\item\em Routine that implements G\+SL numerical integration to calculate the Fishers. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{fisher_8cpp_a51ec10cb30ab1ca997e3c501d9927c1a}{fisher\+\_\+autodiff\+\_\+gsl\+\_\+integration\+\_\+batch\+\_\+mod}} (double $\ast$frequency\+\_\+bounds, string generation\+\_\+method, string sensitivity\+\_\+curve, string detector, double $\ast$$\ast$output, double $\ast$$\ast$error, int base\+\_\+dimension, int full\+\_\+dimension, \mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$parameters, double abserr, double relerr)
\begin{DoxyCompactList}\small\item\em Routine that implements G\+SL numerical integration to calculate the Fishers -- batch modifications version. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{fisher_8cpp_a00c44f9e3bf774c7230d972c64b81326}{fisher\+\_\+autodiff\+\_\+gsl\+\_\+integration\+\_\+batch\+\_\+mod}} (double $\ast$frequency\+\_\+bounds, string generation\+\_\+method, string sensitivity\+\_\+curve, string detector, double $\ast$$\ast$output, double $\ast$$\ast$error, int base\+\_\+dimension, int full\+\_\+dimension, \mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$parameters, double abserr, double relerr, std\+::string error\+\_\+log, bool logerr)
\begin{DoxyCompactList}\small\item\em Routine that implements G\+SL numerical integration to calculate the Fishers -- batch modifications version. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{fisher_8cpp_a0483f09b0c7a53ae7b65d3dff7385697}{calculate\+\_\+integrand\+\_\+autodiff\+\_\+gsl\+\_\+subroutine}} (double frequency, void $\ast$params\+\_\+in)
\begin{DoxyCompactList}\small\item\em Calculates the derivatives of the detector response using automatic differentiation -- one frequency for gsl\+\_\+integration. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{fisher_8cpp_ab8feb32ace0a3f96caa05a3ebe36741c}\label{fisher_8cpp_ab8feb32ace0a3f96caa05a3ebe36741c}} 
\index{fisher.cpp@{fisher.cpp}!calculate\_derivatives\_autodiff@{calculate\_derivatives\_autodiff}}
\index{calculate\_derivatives\_autodiff@{calculate\_derivatives\_autodiff}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{calculate\_derivatives\_autodiff()}{calculate\_derivatives\_autodiff()}}
{\footnotesize\ttfamily void calculate\+\_\+derivatives\+\_\+autodiff (\begin{DoxyParamCaption}\item[{double $\ast$}]{frequency,  }\item[{int}]{length,  }\item[{int}]{dimension,  }\item[{std\+::string}]{generation\+\_\+method,  }\item[{\mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$}]{parameters,  }\item[{std\+::complex$<$ double $>$ $\ast$$\ast$}]{waveform\+\_\+deriv,  }\item[{int $\ast$}]{waveform\+\_\+tapes,  }\item[{std\+::string}]{detector }\end{DoxyParamCaption})}



Calculates the derivatives of the detector response using automatic differentiation. 

Possibly slower than the numerical derivative, but not susceptible to truncation error from finite difference

Higher dimensional fishers actually could be faster

N\+O\+TE\+: dimension parameter A\+L\+W\+A\+YS refers to the dimension of the fisher (ie the length of the source parameter vector), even though the derivatives are computed wrt dimension +1 or dimension + 2 -- the +1(+2) are for the frequency deriv(time deriv) \mbox{\Hypertarget{fisher_8cpp_acae7abfd22bc80580996b8f677be9156}\label{fisher_8cpp_acae7abfd22bc80580996b8f677be9156}} 
\index{fisher.cpp@{fisher.cpp}!calculate\_fisher\_elements\_batch@{calculate\_fisher\_elements\_batch}}
\index{calculate\_fisher\_elements\_batch@{calculate\_fisher\_elements\_batch}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{calculate\_fisher\_elements\_batch()}{calculate\_fisher\_elements\_batch()}}
{\footnotesize\ttfamily void calculate\+\_\+fisher\+\_\+elements\+\_\+batch (\begin{DoxyParamCaption}\item[{double $\ast$}]{frequency,  }\item[{int}]{length,  }\item[{int}]{base\+\_\+dimension,  }\item[{int}]{full\+\_\+dimension,  }\item[{std\+::complex$<$ double $>$ $\ast$$\ast$}]{response\+\_\+deriv,  }\item[{double $\ast$$\ast$}]{output,  }\item[{double $\ast$}]{psd }\end{DoxyParamCaption})}



Subroutine to calculate fisher elements for a subset of the fisher. 

Skips elements that have dimensions (i,j) for i!=j \&\& i$>$base\+\_\+dim \&\& j$>$base\+\_\+dim

Sets non-\/computed elements to zero \mbox{\Hypertarget{fisher_8cpp_a0483f09b0c7a53ae7b65d3dff7385697}\label{fisher_8cpp_a0483f09b0c7a53ae7b65d3dff7385697}} 
\index{fisher.cpp@{fisher.cpp}!calculate\_integrand\_autodiff\_gsl\_subroutine@{calculate\_integrand\_autodiff\_gsl\_subroutine}}
\index{calculate\_integrand\_autodiff\_gsl\_subroutine@{calculate\_integrand\_autodiff\_gsl\_subroutine}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{calculate\_integrand\_autodiff\_gsl\_subroutine()}{calculate\_integrand\_autodiff\_gsl\_subroutine()}}
{\footnotesize\ttfamily double calculate\+\_\+integrand\+\_\+autodiff\+\_\+gsl\+\_\+subroutine (\begin{DoxyParamCaption}\item[{double}]{frequency,  }\item[{void $\ast$}]{params\+\_\+in }\end{DoxyParamCaption})}



Calculates the derivatives of the detector response using automatic differentiation -- one frequency for gsl\+\_\+integration. 

Possibly slower than the numerical derivative, but not susceptible to truncation error from finite difference

Higher dimensional fishers actually could be faster

N\+O\+TE\+: dimension parameter A\+L\+W\+A\+YS refers to the dimension of the fisher (ie the length of the source parameter vector), even though the derivatives are computed wrt dimension +1 or dimension + 2 -- the +1(+2) are for the frequency deriv(time deriv) \mbox{\Hypertarget{fisher_8cpp_af071af4a0f6f8ab05c1cdc76a275cd49}\label{fisher_8cpp_af071af4a0f6f8ab05c1cdc76a275cd49}} 
\index{fisher.cpp@{fisher.cpp}!detect\_adjust\_parameters@{detect\_adjust\_parameters}}
\index{detect\_adjust\_parameters@{detect\_adjust\_parameters}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{detect\_adjust\_parameters()}{detect\_adjust\_parameters()}}
{\footnotesize\ttfamily void detect\+\_\+adjust\+\_\+parameters (\begin{DoxyParamCaption}\item[{double $\ast$}]{freq\+\_\+boundaries,  }\item[{double $\ast$}]{grad\+\_\+freqs,  }\item[{int $\ast$}]{boundary\+\_\+num,  }\item[{\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$}]{input\+\_\+params,  }\item[{std\+::string}]{generation\+\_\+method,  }\item[{std\+::string}]{detector,  }\item[{int}]{dim }\end{DoxyParamCaption})}



Adjust parameters for detector specific configurations (namely, L\+I\+SA introduces extra transitions that needs to be accounted for) 

This is kept separate to improve the modularity of the code. Waveform specific parameters are taken care of in prep\+\_\+fisher\+\_\+calculation and detector specific parameters are taken care of here. \mbox{\Hypertarget{fisher_8cpp_a32601e9b8b1e1e36905da85a4acc5d43}\label{fisher_8cpp_a32601e9b8b1e1e36905da85a4acc5d43}} 
\index{fisher.cpp@{fisher.cpp}!fisher\_autodiff@{fisher\_autodiff}}
\index{fisher\_autodiff@{fisher\_autodiff}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{fisher\_autodiff()}{fisher\_autodiff()}}
{\footnotesize\ttfamily void fisher\+\_\+autodiff (\begin{DoxyParamCaption}\item[{double $\ast$}]{frequency,  }\item[{int}]{length,  }\item[{std\+::string}]{generation\+\_\+method,  }\item[{std\+::string}]{detector,  }\item[{double $\ast$$\ast$}]{output,  }\item[{int}]{dimension,  }\item[{\mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$}]{parameters,  }\item[{int $\ast$}]{amp\+\_\+tapes,  }\item[{int $\ast$}]{phase\+\_\+tapes,  }\item[{double $\ast$}]{noise }\end{DoxyParamCaption})}



Calculates the fisher matrix for the given arguments to within numerical error using automatic differention -\/ slower than the numerical version. 

Build around A\+D\+O\+L-\/C -- A. Walther und A. Griewank\+: Getting started with A\+D\+O\+L-\/C. In U. Naumann und O. Schenk, Combinatorial Scientific Computing, Chapman-\/\+Hall C\+RC Computational Science, pp. 181-\/202 (2012). 
\begin{DoxyParams}{Parameters}
{\em length} & if 0, standard frequency range for the detector is used \\
\hline
{\em output} & double \mbox{[}dimension\mbox{]}\mbox{[}dimension\mbox{]} \\
\hline
{\em amp\+\_\+tapes} & if speed is required, precomputed tapes can be used -\/ assumed the user knows what they\textquotesingle{}re doing, no checks done here to make sure that the number of tapes matches the requirement by the generation\+\_\+method \\
\hline
{\em phase\+\_\+tapes} & if speed is required, precomputed tapes can be used -\/ assumed the user knows what they\textquotesingle{}re doing, no checks done here to make sure that the number of tapes matches the requirement by the generation\+\_\+method \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{fisher_8cpp_a91ee1eb7de2af646ec16426c9660f7e9}\label{fisher_8cpp_a91ee1eb7de2af646ec16426c9660f7e9}} 
\index{fisher.cpp@{fisher.cpp}!fisher\_autodiff\_batch\_mod@{fisher\_autodiff\_batch\_mod}}
\index{fisher\_autodiff\_batch\_mod@{fisher\_autodiff\_batch\_mod}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{fisher\_autodiff\_batch\_mod()}{fisher\_autodiff\_batch\_mod()}}
{\footnotesize\ttfamily void fisher\+\_\+autodiff\+\_\+batch\+\_\+mod (\begin{DoxyParamCaption}\item[{double $\ast$}]{frequency,  }\item[{int}]{length,  }\item[{std\+::string}]{generation\+\_\+method,  }\item[{std\+::string}]{detector,  }\item[{double $\ast$$\ast$}]{output,  }\item[{int}]{base\+\_\+dimension,  }\item[{int}]{full\+\_\+dimension,  }\item[{\mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$}]{parameters,  }\item[{int $\ast$}]{amp\+\_\+tapes,  }\item[{int $\ast$}]{phase\+\_\+tapes,  }\item[{double $\ast$}]{noise }\end{DoxyParamCaption})}



Calculates the fisher matrix for the given arguments to within numerical error using automatic differention in \`{}`batch'\textquotesingle{} mode for modifications to GR. 

Built around A\+D\+O\+L-\/C -- A. Walther und A. Griewank\+: Getting started with A\+D\+O\+L-\/C. In U. Naumann und O. Schenk, Combinatorial Scientific Computing, Chapman-\/\+Hall C\+RC Computational Science, pp. 181-\/202 (2012).

This constructs the fisher for a list of modifications in the usual way, but skips elements of the fisher that correspond to (mod, mod) elements. Specifically, it calculates all the fisher elements except (i, j ) i$>$G\+R\+\_\+dimension \&\& j $>$ G\+R\+\_\+dimension \&\& i!=j.

To find the fisher for one of the modifications, simply remove all the other dimensions associated with the extra modifications using rm\+\_\+fisher\+\_\+dim in \mbox{\hyperlink{util_8h}{util.\+h}}

!\+N\+O\+T\+E!\+:This routine only works as intended when GR is the injected value, that is all the betas are evaluated at 0. And since the covariances between modifications are not computed, this should only be used to look at one modification at a time. 
\begin{DoxyParams}{Parameters}
{\em length} & if 0, standard frequency range for the detector is used \\
\hline
{\em output} & double \mbox{[}dimension\mbox{]}\mbox{[}dimension\mbox{]} \\
\hline
{\em base\+\_\+dimension} & GR dimensionality \\
\hline
{\em full\+\_\+dimension} & Total dimension of the output fisher (ie G\+R\+\_\+dimension + Nmod) \\
\hline
{\em amp\+\_\+tapes} & if speed is required, precomputed tapes can be used -\/ assumed the user knows what they\textquotesingle{}re doing, no checks done here to make sure that the number of tapes matches the requirement by the generation\+\_\+method \\
\hline
{\em phase\+\_\+tapes} & if speed is required, precomputed tapes can be used -\/ assumed the user knows what they\textquotesingle{}re doing, no checks done here to make sure that the number of tapes matches the requirement by the generation\+\_\+method \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{fisher_8cpp_a0c6379dc95a9280ff960f5ebd8eacba0}\label{fisher_8cpp_a0c6379dc95a9280ff960f5ebd8eacba0}} 
\index{fisher.cpp@{fisher.cpp}!fisher\_autodiff\_gsl\_integration@{fisher\_autodiff\_gsl\_integration}}
\index{fisher\_autodiff\_gsl\_integration@{fisher\_autodiff\_gsl\_integration}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{fisher\_autodiff\_gsl\_integration()}{fisher\_autodiff\_gsl\_integration()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void fisher\+\_\+autodiff\+\_\+gsl\+\_\+integration (\begin{DoxyParamCaption}\item[{double $\ast$}]{frequency\+\_\+bounds,  }\item[{string}]{generation\+\_\+method,  }\item[{string}]{sensitivity\+\_\+curve,  }\item[{string}]{detector,  }\item[{double $\ast$$\ast$}]{output,  }\item[{double $\ast$$\ast$}]{error,  }\item[{int}]{dimension,  }\item[{\mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$}]{parameters,  }\item[{double}]{abserr,  }\item[{double}]{relerr }\end{DoxyParamCaption})}



Routine that implements G\+SL numerical integration to calculate the Fishers. 

This can be faster than brute force calculations in fisher\+\_\+autodiff, but that depends

Trade offs\+:

Every element is calculated independently, so no information is retained between elements. In the brute force calculation, there is information reused.

However, time can be saved by spending less time on trivial elements (identically 0 elements, etc) and better spent on complicated elements

Does not have a direct interpretation in terms of integration time, as the scheme is adaptative. Sampling frequency and integration time are \`{}`as good as they need to be'\textquotesingle{} to calculate the fisher

Implements (G\+S\+L\+\_\+\+I\+N\+T\+E\+G\+\_\+\+G\+A\+U\+S\+S15) 
\begin{DoxyParams}[1]{Parameters}
 & {\em frequency\+\_\+bounds} & Bounds of integration in fourier space \\
\hline
 & {\em generation\+\_\+method} & Method of waveform generation \\
\hline
 & {\em sensitivity\+\_\+curve} & Sensitivity curve to be used for the P\+SD -\/-\/ M\+U\+ST BE A\+N\+A\+L\+Y\+T\+IC \\
\hline
 & {\em detector} & Detector to use for the response function \\
\hline
\mbox{\texttt{ out}}  & {\em output} & Output Fisher -\/-\/ must be preallocated -\/-\/ shape \mbox{[}dimension\mbox{]}\mbox{[}dimension\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em error} & Estimated error, as specified by G\+SL\textquotesingle{}s integration -\/-\/ must be preallocated -\/-\/ shape \mbox{[}dimension\mbox{]}\mbox{[}dimension\mbox{]} \\
\hline
 & {\em dimension} & Dimension of the Fisher \\
\hline
 & {\em parameters} & Generation parameters specifying source parameters and waveform options \\
\hline
 & {\em abserr} & Target absolute error (0 if this should be ignored -\/-\/ O\+NE type of error must be specified) \\
\hline
 & {\em relerr} & Target relative error (0 if this should be ignored -\/-\/ O\+NE type of error must be specified) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{fisher_8cpp_af62f3397f996f468b5d78780df8a3167}\label{fisher_8cpp_af62f3397f996f468b5d78780df8a3167}} 
\index{fisher.cpp@{fisher.cpp}!fisher\_autodiff\_gsl\_integration@{fisher\_autodiff\_gsl\_integration}}
\index{fisher\_autodiff\_gsl\_integration@{fisher\_autodiff\_gsl\_integration}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{fisher\_autodiff\_gsl\_integration()}{fisher\_autodiff\_gsl\_integration()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void fisher\+\_\+autodiff\+\_\+gsl\+\_\+integration (\begin{DoxyParamCaption}\item[{double $\ast$}]{frequency\+\_\+bounds,  }\item[{string}]{generation\+\_\+method,  }\item[{string}]{sensitivity\+\_\+curve,  }\item[{string}]{detector,  }\item[{double $\ast$$\ast$}]{output,  }\item[{double $\ast$$\ast$}]{error,  }\item[{int}]{dimension,  }\item[{\mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$}]{parameters,  }\item[{double}]{abserr,  }\item[{double}]{relerr,  }\item[{std\+::string}]{error\+\_\+log,  }\item[{bool}]{logerr }\end{DoxyParamCaption})}



Routine that implements G\+SL numerical integration to calculate the Fishers. 

This can be faster than brute force calculations in fisher\+\_\+autodiff, but that depends

Trade offs\+:

Every element is calculated independently, so no information is retained between elements. In the brute force calculation, there is information reused.

However, time can be saved by spending less time on trivial elements (identically 0 elements, etc) and better spent on complicated elements

Does not have a direct interpretation in terms of integration time, as the scheme is adaptative. Sampling frequency and integration time are \`{}`as good as they need to be'\textquotesingle{} to calculate the fisher

Implements (G\+S\+L\+\_\+\+I\+N\+T\+E\+G\+\_\+\+G\+A\+U\+S\+S15)

Now includes option to log error instead of ending program for certain types of errors 
\begin{DoxyParams}[1]{Parameters}
 & {\em frequency\+\_\+bounds} & Bounds of integration in fourier space \\
\hline
 & {\em generation\+\_\+method} & Method of waveform generation \\
\hline
 & {\em sensitivity\+\_\+curve} & Sensitivity curve to be used for the P\+SD -\/-\/ M\+U\+ST BE A\+N\+A\+L\+Y\+T\+IC \\
\hline
 & {\em detector} & Detector to use for the response function \\
\hline
\mbox{\texttt{ out}}  & {\em output} & Output Fisher -\/-\/ must be preallocated -\/-\/ shape \mbox{[}dimension\mbox{]}\mbox{[}dimension\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em error} & Estimated error, as specified by G\+SL\textquotesingle{}s integration -\/-\/ must be preallocated -\/-\/ shape \mbox{[}dimension\mbox{]}\mbox{[}dimension\mbox{]} \\
\hline
 & {\em dimension} & Dimension of the Fisher \\
\hline
 & {\em parameters} & Generation parameters specifying source parameters and waveform options \\
\hline
 & {\em abserr} & Target absolute error (0 if this should be ignored -\/-\/ O\+NE type of error must be specified) \\
\hline
 & {\em relerr} & Target relative error (0 if this should be ignored -\/-\/ O\+NE type of error must be specified) \\
\hline
 & {\em error\+\_\+log} & File to write non-\/critical error codes to (roundoff error) \\
\hline
 & {\em logerr} & Whether or not to end program with certain error codes, or to log them and continue \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{fisher_8cpp_a51ec10cb30ab1ca997e3c501d9927c1a}\label{fisher_8cpp_a51ec10cb30ab1ca997e3c501d9927c1a}} 
\index{fisher.cpp@{fisher.cpp}!fisher\_autodiff\_gsl\_integration\_batch\_mod@{fisher\_autodiff\_gsl\_integration\_batch\_mod}}
\index{fisher\_autodiff\_gsl\_integration\_batch\_mod@{fisher\_autodiff\_gsl\_integration\_batch\_mod}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{fisher\_autodiff\_gsl\_integration\_batch\_mod()}{fisher\_autodiff\_gsl\_integration\_batch\_mod()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void fisher\+\_\+autodiff\+\_\+gsl\+\_\+integration\+\_\+batch\+\_\+mod (\begin{DoxyParamCaption}\item[{double $\ast$}]{frequency\+\_\+bounds,  }\item[{string}]{generation\+\_\+method,  }\item[{string}]{sensitivity\+\_\+curve,  }\item[{string}]{detector,  }\item[{double $\ast$$\ast$}]{output,  }\item[{double $\ast$$\ast$}]{error,  }\item[{int}]{base\+\_\+dimension,  }\item[{int}]{full\+\_\+dimension,  }\item[{\mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$}]{parameters,  }\item[{double}]{abserr,  }\item[{double}]{relerr }\end{DoxyParamCaption})}



Routine that implements G\+SL numerical integration to calculate the Fishers -- batch modifications version. 

Calculates Fisher for multiple modifications at a time, neglecting covariance between modifications (set to 0 in Fisher)

Modifications M\+U\+ST BE evaluated at 0 for this routine to calculate correct results

This can be faster than brute force calculations in fisher\+\_\+autodiff, but that depends

Trade offs\+:

Every element is calculated independently, so no information is retained between elements. In the brute force calculation, there is information reused.

However, time can be saved by spending less time on trivial elements (identically 0 elements, etc) and better spent on complicated elements

Does not have a direct interpretation in terms of integration time, as the scheme is adaptative. Sampling frequency and integration time are \`{}`as good as they need to be'\textquotesingle{} to calculate the fisher

Implements (G\+S\+L\+\_\+\+I\+N\+T\+E\+G\+\_\+\+G\+A\+U\+S\+S15) 
\begin{DoxyParams}[1]{Parameters}
 & {\em frequency\+\_\+bounds} & Bounds of integration in fourier space \\
\hline
 & {\em generation\+\_\+method} & Method of waveform generation \\
\hline
 & {\em sensitivity\+\_\+curve} & Sensitivity curve to be used for the P\+SD -\/-\/ M\+U\+ST BE A\+N\+A\+L\+Y\+T\+IC \\
\hline
 & {\em detector} & Detector to use for the response function \\
\hline
\mbox{\texttt{ out}}  & {\em output} & Output Fisher -\/-\/ must be preallocated -\/-\/ shape \mbox{[}full\+\_\+dimension\mbox{]}\mbox{[}full\+\_\+dimension\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em error} & Estimated error, as specified by G\+SL\textquotesingle{}s integration -\/-\/ must be preallocated -\/-\/ shape \mbox{[}full\+\_\+dimension\mbox{]}\mbox{[}full\+\_\+dimension\mbox{]} \\
\hline
 & {\em base\+\_\+dimension} & Dimension of base model (ie GR dimension) \\
\hline
 & {\em full\+\_\+dimension} & Full dimension (GR dimension + Nmod) \\
\hline
 & {\em parameters} & Generation parameters specifying source parameters and waveform options \\
\hline
 & {\em abserr} & Target absolute error (0 if this should be ignored -\/-\/ O\+NE type of error must be specified) \\
\hline
 & {\em relerr} & Target relative error (0 if this should be ignored -\/-\/ O\+NE type of error must be specified) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{fisher_8cpp_a00c44f9e3bf774c7230d972c64b81326}\label{fisher_8cpp_a00c44f9e3bf774c7230d972c64b81326}} 
\index{fisher.cpp@{fisher.cpp}!fisher\_autodiff\_gsl\_integration\_batch\_mod@{fisher\_autodiff\_gsl\_integration\_batch\_mod}}
\index{fisher\_autodiff\_gsl\_integration\_batch\_mod@{fisher\_autodiff\_gsl\_integration\_batch\_mod}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{fisher\_autodiff\_gsl\_integration\_batch\_mod()}{fisher\_autodiff\_gsl\_integration\_batch\_mod()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void fisher\+\_\+autodiff\+\_\+gsl\+\_\+integration\+\_\+batch\+\_\+mod (\begin{DoxyParamCaption}\item[{double $\ast$}]{frequency\+\_\+bounds,  }\item[{string}]{generation\+\_\+method,  }\item[{string}]{sensitivity\+\_\+curve,  }\item[{string}]{detector,  }\item[{double $\ast$$\ast$}]{output,  }\item[{double $\ast$$\ast$}]{error,  }\item[{int}]{base\+\_\+dimension,  }\item[{int}]{full\+\_\+dimension,  }\item[{\mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$}]{parameters,  }\item[{double}]{abserr,  }\item[{double}]{relerr,  }\item[{std\+::string}]{error\+\_\+log,  }\item[{bool}]{logerr }\end{DoxyParamCaption})}



Routine that implements G\+SL numerical integration to calculate the Fishers -- batch modifications version. 

Calculates Fisher for multiple modifications at a time, neglecting covariance between modifications (set to 0 in Fisher)

Modifications M\+U\+ST BE evaluated at 0 for this routine to calculate correct results

This can be faster than brute force calculations in fisher\+\_\+autodiff, but that depends

Trade offs\+:

Every element is calculated independently, so no information is retained between elements. In the brute force calculation, there is information reused.

However, time can be saved by spending less time on trivial elements (identically 0 elements, etc) and better spent on complicated elements

Does not have a direct interpretation in terms of integration time, as the scheme is adaptative. Sampling frequency and integration time are \`{}`as good as they need to be'\textquotesingle{} to calculate the fisher

Implements (G\+S\+L\+\_\+\+I\+N\+T\+E\+G\+\_\+\+G\+A\+U\+S\+S15)

Now includes option to log error instead of ending program for certain types of errors 
\begin{DoxyParams}[1]{Parameters}
 & {\em frequency\+\_\+bounds} & Bounds of integration in fourier space \\
\hline
 & {\em generation\+\_\+method} & Method of waveform generation \\
\hline
 & {\em sensitivity\+\_\+curve} & Sensitivity curve to be used for the P\+SD -\/-\/ M\+U\+ST BE A\+N\+A\+L\+Y\+T\+IC \\
\hline
 & {\em detector} & Detector to use for the response function \\
\hline
\mbox{\texttt{ out}}  & {\em output} & Output Fisher -\/-\/ must be preallocated -\/-\/ shape \mbox{[}full\+\_\+dimension\mbox{]}\mbox{[}full\+\_\+dimension\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em error} & Estimated error, as specified by G\+SL\textquotesingle{}s integration -\/-\/ must be preallocated -\/-\/ shape \mbox{[}full\+\_\+dimension\mbox{]}\mbox{[}full\+\_\+dimension\mbox{]} \\
\hline
 & {\em base\+\_\+dimension} & Dimension of base model (ie GR dimension) \\
\hline
 & {\em full\+\_\+dimension} & Full dimension (GR dimension + Nmod) \\
\hline
 & {\em parameters} & Generation parameters specifying source parameters and waveform options \\
\hline
 & {\em abserr} & Target absolute error (0 if this should be ignored -\/-\/ O\+NE type of error must be specified) \\
\hline
 & {\em relerr} & Target relative error (0 if this should be ignored -\/-\/ O\+NE type of error must be specified) \\
\hline
 & {\em error\+\_\+log} & File to write non-\/critical error codes to (roundoff error) \\
\hline
 & {\em logerr} & Whether or not to end program with certain error codes, or to log them and continue \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{fisher_8cpp_a3d084e6f4a371edfc51b6e2a1324d970}\label{fisher_8cpp_a3d084e6f4a371edfc51b6e2a1324d970}} 
\index{fisher.cpp@{fisher.cpp}!fisher\_autodiff\_interp@{fisher\_autodiff\_interp}}
\index{fisher\_autodiff\_interp@{fisher\_autodiff\_interp}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{fisher\_autodiff\_interp()}{fisher\_autodiff\_interp()}}
{\footnotesize\ttfamily void fisher\+\_\+autodiff\+\_\+interp (\begin{DoxyParamCaption}\item[{double $\ast$}]{frequency,  }\item[{int}]{length,  }\item[{std\+::string}]{generation\+\_\+method,  }\item[{std\+::string}]{detector,  }\item[{double $\ast$$\ast$}]{output,  }\item[{int}]{dimension,  }\item[{\mbox{\hyperlink{classgen__params}{gen\+\_\+params}} $\ast$}]{parameters,  }\item[{int}]{downsampling\+\_\+factor,  }\item[{int $\ast$}]{amp\+\_\+tapes,  }\item[{int $\ast$}]{phase\+\_\+tapes,  }\item[{double $\ast$}]{noise }\end{DoxyParamCaption})}



Calculates the fisher matrix for the given arguments to within numerical error using automatic differention -\/ slower than the numerical version. 

Build around A\+D\+O\+L-\/C -- A. Walther und A. Griewank\+: Getting started with A\+D\+O\+L-\/C. In U. Naumann und O. Schenk, Combinatorial Scientific Computing, Chapman-\/\+Hall C\+RC Computational Science, pp. 181-\/202 (2012). 
\begin{DoxyParams}{Parameters}
{\em length} & if 0, standard frequency range for the detector is used \\
\hline
{\em output} & double \mbox{[}dimension\mbox{]}\mbox{[}dimension\mbox{]} \\
\hline
{\em amp\+\_\+tapes} & if speed is required, precomputed tapes can be used -\/ assumed the user knows what they\textquotesingle{}re doing, no checks done here to make sure that the number of tapes matches the requirement by the generation\+\_\+method \\
\hline
{\em phase\+\_\+tapes} & if speed is required, precomputed tapes can be used -\/ assumed the user knows what they\textquotesingle{}re doing, no checks done here to make sure that the number of tapes matches the requirement by the generation\+\_\+method \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{fisher_8cpp_a9794311b4c41baa77ce1975de890115a}\label{fisher_8cpp_a9794311b4c41baa77ce1975de890115a}} 
\index{fisher.cpp@{fisher.cpp}!fisher\_numerical@{fisher\_numerical}}
\index{fisher\_numerical@{fisher\_numerical}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{fisher\_numerical()}{fisher\_numerical()}}
{\footnotesize\ttfamily void fisher\+\_\+numerical (\begin{DoxyParamCaption}\item[{double $\ast$}]{frequency,  }\item[{int}]{length,  }\item[{string}]{generation\+\_\+method,  }\item[{string}]{detector,  }\item[{double $\ast$$\ast$}]{output,  }\item[{int}]{dimension,  }\item[{\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$}]{parameters,  }\item[{int}]{order,  }\item[{int $\ast$}]{amp\+\_\+tapes,  }\item[{int $\ast$}]{phase\+\_\+tapes,  }\item[{double $\ast$}]{noise }\end{DoxyParamCaption})}



Calculates the fisher matrix for the given arguments. 

Utilizes numerical derivatives -- non-\/skyaveraged supports up to 4th order finite difference (sky averaged supports second order only) 
\begin{DoxyParams}{Parameters}
{\em length} & if 0, standard frequency range for the detector is used \\
\hline
{\em output} & double \mbox{[}dimension\mbox{]}\mbox{[}dimension\mbox{]} \\
\hline
{\em order} & Order of the numerical derivative (2 or 4)$\ast$ \\
\hline
{\em amp\+\_\+tapes} & if speed is required, precomputed tapes can be used -\/ assumed the user knows what they\textquotesingle{}re doing, no checks done here to make sure that the number of tapes matches the requirement by the generation\+\_\+method -\/-\/ if using numerical derivatives or speed isn\textquotesingle{}t that important, just set to N\+U\+LL \\
\hline
{\em phase\+\_\+tapes} & if speed is required, precomputed tapes can be used -\/ assumed the user knows what they\textquotesingle{}re doing, no checks done here to make sure that the number of tapes matches the requirement by the generation\+\_\+method \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{fisher_8cpp_ad64b3163d121d715a0eaa22a039ffbe1}\label{fisher_8cpp_ad64b3163d121d715a0eaa22a039ffbe1}} 
\index{fisher.cpp@{fisher.cpp}!local\_generation\_method@{local\_generation\_method}}
\index{local\_generation\_method@{local\_generation\_method}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{local\_generation\_method()}{local\_generation\_method()}}
{\footnotesize\ttfamily std\+::string local\+\_\+generation\+\_\+method (\begin{DoxyParamCaption}\item[{std\+::string}]{generation\+\_\+method }\end{DoxyParamCaption})}



Utility for mapping generation method string to one accepted by the waveform\+\_\+generation routines. 

Certain combinations of parameters are labeled by generation method strings not under the waveform\+\_\+generation routines, so a transformation is needed \mbox{\Hypertarget{fisher_8cpp_a92eebd80a98aa7fb1872bb8700702f77}\label{fisher_8cpp_a92eebd80a98aa7fb1872bb8700702f77}} 
\index{fisher.cpp@{fisher.cpp}!repack\_non\_parameter\_options@{repack\_non\_parameter\_options}}
\index{repack\_non\_parameter\_options@{repack\_non\_parameter\_options}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{repack\_non\_parameter\_options()}{repack\_non\_parameter\_options()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
void repack\+\_\+non\+\_\+parameter\+\_\+options (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ T $>$ $\ast$}]{waveform\+\_\+params,  }\item[{\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$}]{input\+\_\+params,  }\item[{std\+::string}]{gen\+\_\+method }\end{DoxyParamCaption})}



Utilitiy to transfer non-\/parameter options from one \mbox{\hyperlink{classgen__params}{gen\+\_\+params}} structure to another. 

If ppE waveform A\+L\+L\+O\+C\+A\+T\+ES M\+E\+M\+O\+RY -- M\+U\+ST be deallocated \mbox{\Hypertarget{fisher_8cpp_ae9abf5e34ebefb45c534eacd8c6d408b}\label{fisher_8cpp_ae9abf5e34ebefb45c534eacd8c6d408b}} 
\index{fisher.cpp@{fisher.cpp}!repack\_parameters@{repack\_parameters}}
\index{repack\_parameters@{repack\_parameters}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{repack\_parameters()}{repack\_parameters()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
void repack\+\_\+parameters (\begin{DoxyParamCaption}\item[{T $\ast$}]{avec\+\_\+parameters,  }\item[{\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ T $>$ $\ast$}]{a\+\_\+params,  }\item[{std\+::string}]{generation\+\_\+method,  }\item[{int}]{dim,  }\item[{\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$}]{original\+\_\+params }\end{DoxyParamCaption})}



Repack the parameters from an adouble vector to a gen\+\_\+params\+\_\+base$<$adouble$>$ object and freqeuncy. 

This is one of the places where the generation-\/method/dimension/sky\+\_\+average specific modifications should go \mbox{\Hypertarget{fisher_8cpp_ae6b5ad58c5308a1311a93a58f2169e40}\label{fisher_8cpp_ae6b5ad58c5308a1311a93a58f2169e40}} 
\index{fisher.cpp@{fisher.cpp}!time\_phase\_corrected\_derivative\_autodiff@{time\_phase\_corrected\_derivative\_autodiff}}
\index{time\_phase\_corrected\_derivative\_autodiff@{time\_phase\_corrected\_derivative\_autodiff}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{time\_phase\_corrected\_derivative\_autodiff()}{time\_phase\_corrected\_derivative\_autodiff()}}
{\footnotesize\ttfamily void time\+\_\+phase\+\_\+corrected\+\_\+derivative\+\_\+autodiff (\begin{DoxyParamCaption}\item[{double $\ast$$\ast$}]{dt,  }\item[{int}]{length,  }\item[{double $\ast$}]{frequencies,  }\item[{\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$}]{params,  }\item[{std\+::string}]{generation\+\_\+method,  }\item[{int}]{dimension,  }\item[{bool}]{correct\+\_\+time }\end{DoxyParamCaption})}



Computes the derivative of the phase w.\+r.\+t. source parameters AS D\+E\+F\+I\+N\+ED BY F\+I\+S\+H\+ER F\+I\+LE -- hessian of the phase. 

If specific derivatives need to taken, take this routine as a template and write it yourself.

The dt array has shape \mbox{[}dimension+1\mbox{]}\mbox{[}length\mbox{]} (dimension + 1 for the frequency derivative, so dimension should only include the source parameters) \mbox{\Hypertarget{fisher_8cpp_ab3566a9d2c5776b7769f1452bf3f80f3}\label{fisher_8cpp_ab3566a9d2c5776b7769f1452bf3f80f3}} 
\index{fisher.cpp@{fisher.cpp}!time\_phase\_corrected\_derivative\_autodiff\_full\_hess@{time\_phase\_corrected\_derivative\_autodiff\_full\_hess}}
\index{time\_phase\_corrected\_derivative\_autodiff\_full\_hess@{time\_phase\_corrected\_derivative\_autodiff\_full\_hess}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{time\_phase\_corrected\_derivative\_autodiff\_full\_hess()}{time\_phase\_corrected\_derivative\_autodiff\_full\_hess()}}
{\footnotesize\ttfamily void time\+\_\+phase\+\_\+corrected\+\_\+derivative\+\_\+autodiff\+\_\+full\+\_\+hess (\begin{DoxyParamCaption}\item[{double $\ast$$\ast$}]{dt,  }\item[{int}]{length,  }\item[{double $\ast$}]{frequencies,  }\item[{\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$}]{params,  }\item[{std\+::string}]{generation\+\_\+method,  }\item[{int}]{dimension,  }\item[{bool}]{correct\+\_\+time }\end{DoxyParamCaption})}



Computes the derivative of the phase w.\+r.\+t. source parameters AS D\+E\+F\+I\+N\+ED BY F\+I\+S\+H\+ER F\+I\+LE -- hessian of the phase. 

If specific derivatives need to taken, take this routine as a template and write it yourself.

The dt array has shape \mbox{[}dimension+1\mbox{]}\mbox{[}length\mbox{]} (dimension + 1 for the frequency derivative, so dimension should only include the source parameters) \mbox{\Hypertarget{fisher_8cpp_a98ccb5fbfa7dde9dc8d7fb1f38ef5e16}\label{fisher_8cpp_a98ccb5fbfa7dde9dc8d7fb1f38ef5e16}} 
\index{fisher.cpp@{fisher.cpp}!time\_phase\_corrected\_derivative\_autodiff\_numerical@{time\_phase\_corrected\_derivative\_autodiff\_numerical}}
\index{time\_phase\_corrected\_derivative\_autodiff\_numerical@{time\_phase\_corrected\_derivative\_autodiff\_numerical}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{time\_phase\_corrected\_derivative\_autodiff\_numerical()}{time\_phase\_corrected\_derivative\_autodiff\_numerical()}}
{\footnotesize\ttfamily void time\+\_\+phase\+\_\+corrected\+\_\+derivative\+\_\+autodiff\+\_\+numerical (\begin{DoxyParamCaption}\item[{double $\ast$$\ast$}]{dt,  }\item[{int}]{length,  }\item[{double $\ast$}]{frequencies,  }\item[{\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$}]{params,  }\item[{std\+::string}]{generation\+\_\+method,  }\item[{int}]{dimension,  }\item[{bool}]{correct\+\_\+time }\end{DoxyParamCaption})}



Computes the derivative of the phase w.\+r.\+t. source parameters AS D\+E\+F\+I\+N\+ED BY F\+I\+S\+H\+ER F\+I\+LE -- hessian of the phase. 

If specific derivatives need to taken, take this routine as a template and write it yourself.

The dt array has shape \mbox{[}dimension+1\mbox{]}\mbox{[}length\mbox{]} (dimension + 1 for the frequency derivative, so dimension should only include the source parameters)

This takes the autodiff derivative wrt source parameters, and a numerical derivative for the frequency \mbox{\Hypertarget{fisher_8cpp_a093a18b5f2d85ddd1cd37cc22137ae92}\label{fisher_8cpp_a093a18b5f2d85ddd1cd37cc22137ae92}} 
\index{fisher.cpp@{fisher.cpp}!time\_phase\_corrected\_derivative\_autodiff\_sparse@{time\_phase\_corrected\_derivative\_autodiff\_sparse}}
\index{time\_phase\_corrected\_derivative\_autodiff\_sparse@{time\_phase\_corrected\_derivative\_autodiff\_sparse}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{time\_phase\_corrected\_derivative\_autodiff\_sparse()}{time\_phase\_corrected\_derivative\_autodiff\_sparse()}}
{\footnotesize\ttfamily void time\+\_\+phase\+\_\+corrected\+\_\+derivative\+\_\+autodiff\+\_\+sparse (\begin{DoxyParamCaption}\item[{double $\ast$$\ast$}]{dt,  }\item[{int}]{length,  }\item[{double $\ast$}]{frequencies,  }\item[{\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ double $>$ $\ast$}]{params,  }\item[{std\+::string}]{generation\+\_\+method,  }\item[{int}]{dimension,  }\item[{bool}]{correct\+\_\+time }\end{DoxyParamCaption})}



Computes the derivative of the phase w.\+r.\+t. source parameters AS D\+E\+F\+I\+N\+ED BY F\+I\+S\+H\+ER F\+I\+LE -- hessian of the phase. 

If specific derivatives need to taken, take this routine as a template and write it yourself.

The dt array has shape \mbox{[}dimension+1\mbox{]}\mbox{[}length\mbox{]} (dimension + 1 for the frequency derivative, so dimension should only include the source parameters) \mbox{\Hypertarget{fisher_8cpp_a430217adb3e9baf50041ab7fbbd9b2b9}\label{fisher_8cpp_a430217adb3e9baf50041ab7fbbd9b2b9}} 
\index{fisher.cpp@{fisher.cpp}!time\_phase\_corrected\_derivative\_numerical@{time\_phase\_corrected\_derivative\_numerical}}
\index{time\_phase\_corrected\_derivative\_numerical@{time\_phase\_corrected\_derivative\_numerical}!fisher.cpp@{fisher.cpp}}
\doxysubsubsection{\texorpdfstring{time\_phase\_corrected\_derivative\_numerical()}{time\_phase\_corrected\_derivative\_numerical()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
void time\+\_\+phase\+\_\+corrected\+\_\+derivative\+\_\+numerical (\begin{DoxyParamCaption}\item[{T $\ast$$\ast$}]{dt,  }\item[{int}]{length,  }\item[{T $\ast$}]{frequencies,  }\item[{\mbox{\hyperlink{classgen__params__base}{gen\+\_\+params\+\_\+base}}$<$ T $>$ $\ast$}]{params,  }\item[{std\+::string}]{generation\+\_\+method,  }\item[{int}]{dimension,  }\item[{bool}]{correct\+\_\+time }\end{DoxyParamCaption})}



Computes the derivative of the phase w.\+r.\+t. source parameters AS D\+E\+F\+I\+N\+ED BY F\+I\+S\+H\+ER F\+I\+LE -- hessian of the phase -- numerical. 

IN P\+R\+O\+G\+R\+E\+SS -- DO N\+OT U\+SE

If specific derivatives need to taken, take this routine as a template and write it yourself.

The dt array has shape \mbox{[}dimension+1\mbox{]}\mbox{[}length\mbox{]} (dimension + 1 for the frequency derivative, so dimension should only include the (full) source parameters) 