<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GW Analysis Tools: include/gwat/waveform_util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GW Analysis Tools
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_147dca7e63280c60f9b0a606d8310551.html">gwat</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">waveform_util.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="waveform__generator_8h_source.html">waveform_generator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;gsl/gsl_integration.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for waveform_util.h:</div>
<div class="dyncontent">
<div class="center"><img src="waveform__util_8h__incl.png" border="0" usemap="#include_2gwat_2waveform__util_8h" alt=""/></div>
<!-- MAP 0 -->
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="waveform__util_8h__dep__incl.png" border="0" usemap="#include_2gwat_2waveform__util_8hdep" alt=""/></div>
<!-- MAP 1 -->
</div>
</div>
<p><a href="waveform__util_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a92474a9479a801dcbb9a6d50aa8d3670"><td class="memItemLeft" align="right" valign="top"><a id="a92474a9479a801dcbb9a6d50aa8d3670"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>data_snr</b> (double *frequencies, int length, std::complex&lt; double &gt; *data, std::complex&lt; double &gt; *response, double *psd)</td></tr>
<tr class="separator:a92474a9479a801dcbb9a6d50aa8d3670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5e9bfac97929ed68c247c3ff90fca2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a0a5e9bfac97929ed68c247c3ff90fca2">data_snr_maximized_extrinsic</a> (double *frequencies, int length, std::complex&lt; double &gt; *data, double *psd, std::string detector, std::string generation_method, <a class="el" href="classgen__params.html">gen_params</a> *param)</td></tr>
<tr class="memdesc:a0a5e9bfac97929ed68c247c3ff90fca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to calculate the snr of a fourier transformed data stream while maximizing over the coalescence parameters phic and tc.  <a href="waveform__util_8h.html#a0a5e9bfac97929ed68c247c3ff90fca2">More...</a><br /></td></tr>
<tr class="separator:a0a5e9bfac97929ed68c247c3ff90fca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85abee44a54e906762d980f56b76bc46"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a85abee44a54e906762d980f56b76bc46">data_snr_maximized_extrinsic</a> (double *frequencies, int length, double *data_real, double *data_imag, double *psd, std::string detector, std::string generation_method, <a class="el" href="classgen__params.html">gen_params</a> *param)</td></tr>
<tr class="memdesc:a85abee44a54e906762d980f56b76bc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Light wrapper for the data_snr_maximized_extrinsic method.  <a href="waveform__util_8h.html#a85abee44a54e906762d980f56b76bc46">More...</a><br /></td></tr>
<tr class="separator:a85abee44a54e906762d980f56b76bc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e74aae0c49a3854f81e349413b20e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a65e74aae0c49a3854f81e349413b20e5">calculate_snr</a> (std::string sensitivity_curve, std::complex&lt; double &gt; *waveform, double *frequencies, int length)</td></tr>
<tr class="memdesc:a65e74aae0c49a3854f81e349413b20e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Caclulates the snr given a detector and waveform (complex) and frequencies.  <a href="waveform__util_8h.html#a65e74aae0c49a3854f81e349413b20e5">More...</a><br /></td></tr>
<tr class="separator:a65e74aae0c49a3854f81e349413b20e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e923c1ceedf04aab52a9635a67e2aa2"><td class="memItemLeft" align="right" valign="top"><a id="a6e923c1ceedf04aab52a9635a67e2aa2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_snr_internal</b> (double *psd, std::complex&lt; double &gt; *waveform, double *frequencies, int length)</td></tr>
<tr class="separator:a6e923c1ceedf04aab52a9635a67e2aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24123fc7426785f73e4b393af556e3b2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a24123fc7426785f73e4b393af556e3b2">calculate_snr</a> (std::string sensitivity_curve, std::string detector, std::string generation_method, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, double *frequencies, int length)</td></tr>
<tr class="memdesc:a24123fc7426785f73e4b393af556e3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine to calculate the SNR of a template with GSL quadrature integration.  <a href="waveform__util_8h.html#a24123fc7426785f73e4b393af556e3b2">More...</a><br /></td></tr>
<tr class="separator:a24123fc7426785f73e4b393af556e3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae457f376ac6868d88fa7c428a1cc0798"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#ae457f376ac6868d88fa7c428a1cc0798">calculate_snr_gsl</a> (double *snr, std::string sensitivity_curve, std::string detector, std::string generation_method, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, double f_min, double f_max, double relative_error)</td></tr>
<tr class="memdesc:ae457f376ac6868d88fa7c428a1cc0798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine to calculate the SNR of a template with GSL quadrature integration.  <a href="waveform__util_8h.html#ae457f376ac6868d88fa7c428a1cc0798">More...</a><br /></td></tr>
<tr class="separator:ae457f376ac6868d88fa7c428a1cc0798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6b3d3d9c2f2fee67faef89f435f780"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a7a6b3d3d9c2f2fee67faef89f435f780">calculate_snr_gsl</a> (double *snr, std::string sensitivity_curve, std::string detector, std::string generation_method, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, double f_min, double f_max, double relative_error, gsl_integration_workspace *w, int np)</td></tr>
<tr class="separator:a7a6b3d3d9c2f2fee67faef89f435f780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4a9bc1f23ef60f44b6497cbc0a1c62"><td class="memItemLeft" align="right" valign="top"><a id="aac4a9bc1f23ef60f44b6497cbc0a1c62"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#aac4a9bc1f23ef60f44b6497cbc0a1c62">integrand_snr_SA_subroutine</a> (double f, void *subroutine_params)</td></tr>
<tr class="memdesc:aac4a9bc1f23ef60f44b6497cbc0a1c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to calculate the SNR integrand for sky-averaged waveforms. <br /></td></tr>
<tr class="separator:aac4a9bc1f23ef60f44b6497cbc0a1c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61996edcf8006475f688ef5ab6a22be8"><td class="memItemLeft" align="right" valign="top"><a id="a61996edcf8006475f688ef5ab6a22be8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a61996edcf8006475f688ef5ab6a22be8">integrand_snr_subroutine</a> (double f, void *subroutine_params)</td></tr>
<tr class="memdesc:a61996edcf8006475f688ef5ab6a22be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to calculate the SNR integrand for full waveforms. <br /></td></tr>
<tr class="separator:a61996edcf8006475f688ef5ab6a22be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc4f9ff901f2b97fe3c90464eaf6ddd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acfc4f9ff901f2b97fe3c90464eaf6ddd"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#acfc4f9ff901f2b97fe3c90464eaf6ddd">fourier_detector_response_horizon</a> (T *frequencies, int length, std::complex&lt; T &gt; *hplus, std::complex&lt; T &gt; *hcross, std::complex&lt; T &gt; *detector_response, T theta, T phi, std::string detector)</td></tr>
<tr class="separator:acfc4f9ff901f2b97fe3c90464eaf6ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e4717d9625b9ab1f288934628a152f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a46e4717d9625b9ab1f288934628a152f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a46e4717d9625b9ab1f288934628a152f">fourier_detector_response_horizon</a> (T *frequencies, int length, std::complex&lt; T &gt; *hplus, std::complex&lt; T &gt; *hcross, std::complex&lt; T &gt; *detector_response, T theta, T phi, T psi, std::string detector)</td></tr>
<tr class="separator:a46e4717d9625b9ab1f288934628a152f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5544fbdbe68fb348d59fa7714fa35e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ada5544fbdbe68fb348d59fa7714fa35e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#ada5544fbdbe68fb348d59fa7714fa35e">fourier_detector_response_horizon</a> (T *frequencies, int length, std::complex&lt; T &gt; *response, std::string detector, std::string generation_method, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *parameters)</td></tr>
<tr class="memdesc:ada5544fbdbe68fb348d59fa7714fa35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to produce the detector response caused by impinging gravitational waves from a quasi-circular binary.  <a href="waveform__util_8h.html#ada5544fbdbe68fb348d59fa7714fa35e">More...</a><br /></td></tr>
<tr class="separator:ada5544fbdbe68fb348d59fa7714fa35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e4a354390ac1f31d58d4cbd1090e25"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad3e4a354390ac1f31d58d4cbd1090e25"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#ad3e4a354390ac1f31d58d4cbd1090e25">fourier_detector_response_equatorial</a> (T *frequencies, int length, std::complex&lt; T &gt; *hplus, std::complex&lt; T &gt; *hcross, std::complex&lt; T &gt; *detector_response, T ra, T dec, T psi, double gmst, T *times, T LISA_alpha0, T LISA_phi0, T theta_j_ecl, T phi_j_ecl, std::string detector)</td></tr>
<tr class="separator:ad3e4a354390ac1f31d58d4cbd1090e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234c1a71c579c913e0c1033d951dbbe5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a234c1a71c579c913e0c1033d951dbbe5"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a234c1a71c579c913e0c1033d951dbbe5">fourier_detector_response_equatorial</a> (T *frequencies, int length, std::complex&lt; T &gt; *response, std::string detector, std::string generation_method, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *parameters)</td></tr>
<tr class="memdesc:a234c1a71c579c913e0c1033d951dbbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to produce the detector response caused by impinging gravitational waves from a quasi-circular binary for equatorial coordinates for TERRESTIAL detectors, where the earth's rotation during the signal is minor.  <a href="waveform__util_8h.html#a234c1a71c579c913e0c1033d951dbbe5">More...</a><br /></td></tr>
<tr class="separator:a234c1a71c579c913e0c1033d951dbbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2665d6e33ace647dc022cdbdc66045"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6f2665d6e33ace647dc022cdbdc66045"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a6f2665d6e33ace647dc022cdbdc66045">fourier_detector_response_equatorial</a> (T *frequencies, int length, std::complex&lt; T &gt; *response, std::string detector, std::string generation_method, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *parameters, T *times)</td></tr>
<tr class="memdesc:a6f2665d6e33ace647dc022cdbdc66045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to produce the detector response caused by impinging gravitational waves from a quasi-circular binary for equatorial coordinates.  <a href="waveform__util_8h.html#a6f2665d6e33ace647dc022cdbdc66045">More...</a><br /></td></tr>
<tr class="separator:a6f2665d6e33ace647dc022cdbdc66045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759e633c6a807efa7b48fd66eb74ccf6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a759e633c6a807efa7b48fd66eb74ccf6"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a759e633c6a807efa7b48fd66eb74ccf6">fourier_detector_response</a> (T *frequencies, int length, std::complex&lt; T &gt; *response, std::string detector, std::string generation_method, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *parameters, T *times=NULL)</td></tr>
<tr class="memdesc:a759e633c6a807efa7b48fd66eb74ccf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to handle all detector_response calls &ndash; horizon and equatorial.  <a href="waveform__util_8h.html#a759e633c6a807efa7b48fd66eb74ccf6">More...</a><br /></td></tr>
<tr class="separator:a759e633c6a807efa7b48fd66eb74ccf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806f40462cbcdff3d062ac7fa1275915"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a806f40462cbcdff3d062ac7fa1275915">boundary_number</a> (std::string method)</td></tr>
<tr class="memdesc:a806f40462cbcdff3d062ac7fa1275915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to inform the fisher routine how many logical boundaries should be expected.  <a href="waveform__util_8h.html#a806f40462cbcdff3d062ac7fa1275915">More...</a><br /></td></tr>
<tr class="separator:a806f40462cbcdff3d062ac7fa1275915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6f9e72d0309cfbc84a0e108708c635"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a7b6f9e72d0309cfbc84a0e108708c635">time_phase_corrected_autodiff</a> (double *times, int length, double *frequencies, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, bool correct_time, int *tapes_in=NULL)</td></tr>
<tr class="memdesc:a7b6f9e72d0309cfbc84a0e108708c635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from phase to time AUTODIFFERENTIATION using ADOL-C.  <a href="waveform__util_8h.html#a7b6f9e72d0309cfbc84a0e108708c635">More...</a><br /></td></tr>
<tr class="separator:a7b6f9e72d0309cfbc84a0e108708c635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c78a73b052376ec0c8acddcedb202bd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6c78a73b052376ec0c8acddcedb202bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a6c78a73b052376ec0c8acddcedb202bd">time_phase_corrected</a> (T *times, int length, T *frequencies, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *params, std::string generation_method, bool correct_time)</td></tr>
<tr class="memdesc:a6c78a73b052376ec0c8acddcedb202bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from phase to time NUMERICAL.  <a href="waveform__util_8h.html#a6c78a73b052376ec0c8acddcedb202bd">More...</a><br /></td></tr>
<tr class="separator:a6c78a73b052376ec0c8acddcedb202bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505fe9689f0a2c8484fd2edb087d7f37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a505fe9689f0a2c8484fd2edb087d7f37">fourier_detector_amplitude_phase</a> (double *frequencies, int length, double *amplitude, double *phase, std::string detector, std::string generation_method, <a class="el" href="classgen__params.html">gen_params</a> *parameters)</td></tr>
<tr class="memdesc:a505fe9689f0a2c8484fd2edb087d7f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the amplitude (magnitude) and phase (argument) of the response of a given detector.  <a href="waveform__util_8h.html#a505fe9689f0a2c8484fd2edb087d7f37">More...</a><br /></td></tr>
<tr class="separator:a505fe9689f0a2c8484fd2edb087d7f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f454b07417d139266fd494ddfab1dcc"><td class="memTemplParams" colspan="2"><a id="a1f454b07417d139266fd494ddfab1dcc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1f454b07417d139266fd494ddfab1dcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_orientation_coords</b> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *parameters, std::string generation_method, std::string detector)</td></tr>
<tr class="separator:a1f454b07417d139266fd494ddfab1dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fd9ac5b289b41ef09ebed4b7841a7d"><td class="memTemplParams" colspan="2"><a id="ad8fd9ac5b289b41ef09ebed4b7841a7d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad8fd9ac5b289b41ef09ebed4b7841a7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_extrinsic_angles</b> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *params)</td></tr>
<tr class="separator:ad8fd9ac5b289b41ef09ebed4b7841a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01ae1e6e5b37e27d28975374d504d75"><td class="memItemLeft" align="right" valign="top"><a id="ad01ae1e6e5b37e27d28975374d504d75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign_freq_boundaries</b> (double *freq_boundaries, double *intermediate_freqs, int boundary_num, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *input_params, std::string generation_method)</td></tr>
<tr class="separator:ad01ae1e6e5b37e27d28975374d504d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f19ab5b9b95d8e31d0cca87a4f560c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#ad8f19ab5b9b95d8e31d0cca87a4f560c">integration_bounds</a> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, std::string detector, std::string sensitivity_curve, double fmin, double fmax, double signal_to_noise, double tol, double *integration_bounds)</td></tr>
<tr class="memdesc:ad8f19ab5b9b95d8e31d0cca87a4f560c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to find the integration bounds for Fisher matrices for increasing speed of Fisher evaluation.  <a href="waveform__util_8h.html#ad8f19ab5b9b95d8e31d0cca87a4f560c">More...</a><br /></td></tr>
<tr class="separator:ad8f19ab5b9b95d8e31d0cca87a4f560c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7ec6fc6fb00649edbba1122b64db1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a1d7ec6fc6fb00649edbba1122b64db1b">integration_interval</a> (double sampling_freq, double integration_time, std::string detector, std::string sensitivity_curve, std::string generation_method, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, double *freq_bounds)</td></tr>
<tr class="memdesc:a1d7ec6fc6fb00649edbba1122b64db1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the integration bounds for the log likelihood or fisher given some observation time, sampling frequency, detector, and sensitivity curve.  <a href="waveform__util_8h.html#a1d7ec6fc6fb00649edbba1122b64db1b">More...</a><br /></td></tr>
<tr class="separator:a1d7ec6fc6fb00649edbba1122b64db1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3400a327a02e56c1b8defbd342d0cfee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a3400a327a02e56c1b8defbd342d0cfee">Tbm_to_freq</a> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, double Tbm, double *freq, double tol)</td></tr>
<tr class="memdesc:a3400a327a02e56c1b8defbd342d0cfee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to Calculate the time before merger using numerical methods.  <a href="waveform__util_8h.html#a3400a327a02e56c1b8defbd342d0cfee">More...</a><br /></td></tr>
<tr class="separator:a3400a327a02e56c1b8defbd342d0cfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee807356a4303fb65463fde5286ea28"><td class="memTemplParams" colspan="2"><a id="a8ee807356a4303fb65463fde5286ea28"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8ee807356a4303fb65463fde5286ea28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>postmerger_params</b> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *params, std::string generation_method, T *fpeak, T *fdamp, T *fRD)</td></tr>
<tr class="separator:a8ee807356a4303fb65463fde5286ea28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8404fb320da8cbbf323284e98c915b1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a8404fb320da8cbbf323284e98c915b1a">threshold_times</a> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, double T_obs, double T_wait, double f_lower, double f_upper, std::string SN, double SNR_thresh, double *threshold_times_out, double tolerance)</td></tr>
<tr class="memdesc:a8404fb320da8cbbf323284e98c915b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for calculating the threshold times before merger that result in an SNR&gt;SNR_thresh.  <a href="waveform__util_8h.html#a8404fb320da8cbbf323284e98c915b1a">More...</a><br /></td></tr>
<tr class="separator:a8404fb320da8cbbf323284e98c915b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50c071471073e81a08351efb9594313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#ab50c071471073e81a08351efb9594313">threshold_times</a> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, double T_obs, double T_wait, double *freqs, double *SN, int length, double SNR_thresh, double *threshold_times_out, double tolerance)</td></tr>
<tr class="memdesc:ab50c071471073e81a08351efb9594313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for calculating the threshold times before merger that result in an SNR&gt;SNR_thresh.  <a href="waveform__util_8h.html#ab50c071471073e81a08351efb9594313">More...</a><br /></td></tr>
<tr class="separator:ab50c071471073e81a08351efb9594313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c07b6a1a7f0ed05b79c8ef3abaa2ba"><td class="memItemLeft" align="right" valign="top"><a id="a21c07b6a1a7f0ed05b79c8ef3abaa2ba"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>integrand_threshold_subroutine</b> (double f, void *subroutine_params)</td></tr>
<tr class="separator:a21c07b6a1a7f0ed05b79c8ef3abaa2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048dd8b6f27c6641faef923970bb0126"><td class="memItemLeft" align="right" valign="top"><a id="a048dd8b6f27c6641faef923970bb0126"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>snr_threshold_subroutine</b> (double fmin, double fmax, double rel_err, <a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, std::string SN, gsl_integration_workspace *w, int np)</td></tr>
<tr class="separator:a048dd8b6f27c6641faef923970bb0126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61791d5e6231ea72ce813aa3501a8ee4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waveform__util_8h.html#a61791d5e6231ea72ce813aa3501a8ee4">threshold_times_gsl</a> (<a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *params, std::string generation_method, double T_obs, double T_wait, double fmin, double fmax, std::string SN, double SNR_thresh, double *threshold_times_out, double tolerance, gsl_integration_workspace *w, int np)</td></tr>
<tr class="memdesc:a61791d5e6231ea72ce813aa3501a8ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for calculating the threshold times before merger that result in an SNR&gt;SNR_thresh &ndash;GSL quad integration implementation.  <a href="waveform__util_8h.html#a61791d5e6231ea72ce813aa3501a8ee4">More...</a><br /></td></tr>
<tr class="separator:a61791d5e6231ea72ce813aa3501a8ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for waveform specific utilites </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a806f40462cbcdff3d062ac7fa1275915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806f40462cbcdff3d062ac7fa1275915">&#9670;&nbsp;</a></span>boundary_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int boundary_number </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to inform the fisher routine how many logical boundaries should be expected. </p>
<p>The automatic derivative code requires a new tape for each logical branch of the program, so each waveform_generation method needs to add the number of branches here </p>

</div>
</div>
<a id="a65e74aae0c49a3854f81e349413b20e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e74aae0c49a3854f81e349413b20e5">&#9670;&nbsp;</a></span>calculate_snr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double calculate_snr </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>waveform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Caclulates the snr given a detector and waveform (complex) and frequencies. </p>
<p>This function computes the un-normalized snr: \sqrt( ( H | H ) ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensitivity_curve</td><td>detector name - must match the string of populate_noise precisely </td></tr>
    <tr><td class="paramname">waveform</td><td>complex waveform </td></tr>
    <tr><td class="paramname">frequencies</td><td>double array of frequencies that the waveform is evaluated at </td></tr>
    <tr><td class="paramname">length</td><td>length of the above two arrays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24123fc7426785f73e4b393af556e3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24123fc7426785f73e4b393af556e3b2">&#9670;&nbsp;</a></span>calculate_snr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double calculate_snr </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine to calculate the SNR of a template with GSL quadrature integration. </p>
<p>Sometimes, this is faster than the `&lsquo;grid&rsquo;' style integration</p>
<p>Supports sky-averaged templates, but this should only be used with non-precessing waveforms </p>

</div>
</div>
<a id="ae457f376ac6868d88fa7c428a1cc0798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae457f376ac6868d88fa7c428a1cc0798">&#9670;&nbsp;</a></span>calculate_snr_gsl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int calculate_snr_gsl </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>snr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relative_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine to calculate the SNR of a template with GSL quadrature integration. </p>
<p>Sometimes, this is faster than the `&lsquo;grid&rsquo;' style integration</p>
<p>Supports sky-averaged templates, but this should only be used with non-precessing waveforms </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">snr</td><td>SNR </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sensitivity_curve</td><td>Noise curve </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>Detector to compute response -- can be empty is SA </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>Generation method </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">params</td><td>Source Parameters </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">f_min</td><td>Lower frequency bound </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">f_max</td><td>Upper frequency bound </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">relative_error</td><td>Relative error threshold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a6b3d3d9c2f2fee67faef89f435f780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6b3d3d9c2f2fee67faef89f435f780">&#9670;&nbsp;</a></span>calculate_snr_gsl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int calculate_snr_gsl </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>snr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relative_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_integration_workspace *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensitivity_curve</td><td>Noise curve </td></tr>
    <tr><td class="paramname">detector</td><td>Detector to compute response -- can be empty is SA </td></tr>
    <tr><td class="paramname">generation_method</td><td>Generation method </td></tr>
    <tr><td class="paramname">params</td><td>Source Parameters </td></tr>
    <tr><td class="paramname">f_min</td><td>Lower frequency bound </td></tr>
    <tr><td class="paramname">f_max</td><td>Upper frequency bound </td></tr>
    <tr><td class="paramname">relative_error</td><td>Relative error threshold </td></tr>
    <tr><td class="paramname">w</td><td>User-allocated gsl_integration_workspace </td></tr>
    <tr><td class="paramname">np</td><td>Size of gsl_integration_workspace allocation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85abee44a54e906762d980f56b76bc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85abee44a54e906762d980f56b76bc46">&#9670;&nbsp;</a></span>data_snr_maximized_extrinsic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double data_snr_maximized_extrinsic </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>data_real</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>data_imag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>psd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Light wrapper for the data_snr_maximized_extrinsic method. </p>
<p>Splits the data into real and imaginary, so all the arguments are C-safe </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequencies</td><td>Frequencies used by data </td></tr>
    <tr><td class="paramname">length</td><td>length of the data </td></tr>
    <tr><td class="paramname">data_real</td><td>input data in the fourier domain -- real part </td></tr>
    <tr><td class="paramname">data_imag</td><td>input data in the fourier domain -- imaginary part </td></tr>
    <tr><td class="paramname">psd</td><td>PSD for the detector that created the data </td></tr>
    <tr><td class="paramname">detector</td><td>Name of the detector --See noise_util for options </td></tr>
    <tr><td class="paramname">generation_method</td><td>Generation method for the template -- See waveform_generation.cpp for options </td></tr>
    <tr><td class="paramname">param</td><td><a class="el" href="classgen__params.html" title="convience wrapper for the gen_params_base class">gen_params</a> structure for the template </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a5e9bfac97929ed68c247c3ff90fca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5e9bfac97929ed68c247c3ff90fca2">&#9670;&nbsp;</a></span>data_snr_maximized_extrinsic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double data_snr_maximized_extrinsic </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>psd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to calculate the snr of a fourier transformed data stream while maximizing over the coalescence parameters phic and tc. </p>
<p>The <a class="el" href="classgen__params.html" title="convience wrapper for the gen_params_base class">gen_params</a> structure holds the parameters for the template to be used (the maximimum likelihood parameters) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequencies</td><td>Frequencies used by data </td></tr>
    <tr><td class="paramname">length</td><td>length of the data </td></tr>
    <tr><td class="paramname">data</td><td>input data in the fourier domain </td></tr>
    <tr><td class="paramname">psd</td><td>PSD for the detector that created the data </td></tr>
    <tr><td class="paramname">detector</td><td>Name of the detector --See noise_util for options </td></tr>
    <tr><td class="paramname">generation_method</td><td>Generation method for the template -- See waveform_generation.cpp for options </td></tr>
    <tr><td class="paramname">param</td><td><a class="el" href="classgen__params.html" title="convience wrapper for the gen_params_base class">gen_params</a> structure for the template </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a505fe9689f0a2c8484fd2edb087d7f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505fe9689f0a2c8484fd2edb087d7f37">&#9670;&nbsp;</a></span>fourier_detector_amplitude_phase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_detector_amplitude_phase </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>amplitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params.html">gen_params</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the amplitude (magnitude) and phase (argument) of the response of a given detector. </p>
<p>This is for general waveforms, and will work for precessing waveforms</p>
<p>Not as fast as non-precessing, but that can't be helped. MUST include plus/cross polarizations </p>

</div>
</div>
<a id="a759e633c6a807efa7b48fd66eb74ccf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759e633c6a807efa7b48fd66eb74ccf6">&#9670;&nbsp;</a></span>fourier_detector_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int fourier_detector_response </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>times</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper to handle all detector_response calls &ndash; horizon and equatorial. </p>

</div>
</div>
<a id="ad3e4a354390ac1f31d58d4cbd1090e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e4a354390ac1f31d58d4cbd1090e25">&#9670;&nbsp;</a></span>fourier_detector_response_equatorial() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int fourier_detector_response_equatorial </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>hplus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>hcross</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>detector_response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gmst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>LISA_alpha0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>LISA_phi0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>theta_j_ecl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>phi_j_ecl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequencies</td><td>array of frequencies corresponding to waveform </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>length of frequency/waveform arrays </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hcross</td><td>precomputed cross polarization of the waveform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detector_response</td><td>detector response </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ra</td><td>Right Ascension in rad </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dec</td><td>Declination in rad </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">psi</td><td>polarization angle (rad) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">gmst</td><td>greenwich mean sidereal time </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>detector - list of supported detectors in noise_util </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a234c1a71c579c913e0c1033d951dbbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234c1a71c579c913e0c1033d951dbbe5">&#9670;&nbsp;</a></span>fourier_detector_response_equatorial() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int fourier_detector_response_equatorial </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to produce the detector response caused by impinging gravitational waves from a quasi-circular binary for equatorial coordinates for TERRESTIAL detectors, where the earth's rotation during the signal is minor. </p>
<p>By using the structure parameter, the function is allowed to be more flexible in using different method of waveform generation - not all methods use the same parameters</p>
<p>This puts the responsibility on the user to pass the necessary parameters</p>
<p>Detector options include classic interferometers like LIGO/VIRGO (coming soon: ET and LISA)</p>
<p>This is a wrapper that combines generation with response functions: if producing mulitple responses for one waveform (ie stacking Hanford, Livingston, and VIRGO), it will be considerably more efficient to calculate the waveform once, then combine each response manually </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequencies</td><td>double array of frequencies for the waveform to be evaluated at </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>integer length of all the arrays </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>complex array for the output plus polarization waveform </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>String that corresponds to the generation method - MUST BE SPELLED EXACTLY </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parameters</td><td>structure containing all the source parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f2665d6e33ace647dc022cdbdc66045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2665d6e33ace647dc022cdbdc66045">&#9670;&nbsp;</a></span>fourier_detector_response_equatorial() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int fourier_detector_response_equatorial </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>times</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to produce the detector response caused by impinging gravitational waves from a quasi-circular binary for equatorial coordinates. </p>
<p>By using the structure parameter, the function is allowed to be more flexible in using different method of waveform generation - not all methods use the same parameters</p>
<p>This puts the responsibility on the user to pass the necessary parameters</p>
<p>Detector options include classic interferometers like LIGO/VIRGO (coming soon: ET and LISA)</p>
<p>This is a wrapper that combines generation with response functions: if producing mulitple responses for one waveform (ie stacking Hanford, Livingston, and VIRGO), it will be considerably more efficient to calculate the waveform once, then combine each response manually </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequencies</td><td>double array of frequencies for the waveform to be evaluated at </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>integer length of all the arrays </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>complex array for the output plus polarization waveform </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>String that corresponds to the generation method - MUST BE SPELLED EXACTLY </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parameters</td><td>structure containing all the source parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfc4f9ff901f2b97fe3c90464eaf6ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc4f9ff901f2b97fe3c90464eaf6ddd">&#9670;&nbsp;</a></span>fourier_detector_response_horizon() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int fourier_detector_response_horizon </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>hplus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>hcross</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>detector_response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequencies</td><td>array of frequencies corresponding to waveform </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>length of frequency/waveform arrays </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hcross</td><td>precomputed cross polarization of the waveform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detector_response</td><td>detector response </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">theta</td><td>polar angle (rad) theta in detector frame </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">phi</td><td>azimuthal angle (rad) phi in detector frame </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>detector - list of supported detectors in noise_util </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46e4717d9625b9ab1f288934628a152f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e4717d9625b9ab1f288934628a152f">&#9670;&nbsp;</a></span>fourier_detector_response_horizon() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int fourier_detector_response_horizon </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>hplus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>hcross</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>detector_response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequencies</td><td>array of frequencies corresponding to waveform </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>length of frequency/waveform arrays </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hcross</td><td>precomputed cross polarization of the waveform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detector_response</td><td>detector response </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">theta</td><td>polar angle (rad) theta in detector frame </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">phi</td><td>azimuthal angle (rad) phi in detector frame </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">psi</td><td>polarization angle (rad) phi in detector frame </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>detector - list of supported detectors in noise_util </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada5544fbdbe68fb348d59fa7714fa35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5544fbdbe68fb348d59fa7714fa35e">&#9670;&nbsp;</a></span>fourier_detector_response_horizon() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int fourier_detector_response_horizon </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to produce the detector response caused by impinging gravitational waves from a quasi-circular binary. </p>
<p>By using the structure parameter, the function is allowed to be more flexible in using different method of waveform generation - not all methods use the same parameters</p>
<p>This puts the responsibility on the user to pass the necessary parameters</p>
<p>Detector options include classic interferometers like LIGO/VIRGO (coming soon: ET and LISA)</p>
<p>This is a wrapper that combines generation with response functions: if producing mulitple responses for one waveform (ie stacking Hanford, Livingston, and VIRGO), it will be considerably more efficient to calculate the waveform once, then combine each response manually </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frequencies</td><td>double array of frequencies for the waveform to be evaluated at </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>integer length of all the arrays </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>complex array for the output plus polarization waveform </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>String that corresponds to the generation method - MUST BE SPELLED EXACTLY </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parameters</td><td>structure containing all the source parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8f19ab5b9b95d8e31d0cca87a4f560c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f19ab5b9b95d8e31d0cca87a4f560c">&#9670;&nbsp;</a></span>integration_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void integration_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>signal_to_noise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>integration_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to find the integration bounds for Fisher matrices for increasing speed of Fisher evaluation. </p>
<p>Numerically finds the frequencies at which the Fisher should be evaluated at.</p>
<p>Uses the bisection search algorithm for the cases where the waveform enters/leaves the band at SNR&gt;1</p>
<p>Uses a 100 pt grid search (logarithmically spaced) if the signal has SNR&lt;1 when entering and leaving</p>
<p>integrand_bounds[0] ~ frequency at which |h|/(sqrt S) ~signal_to_noise +/- tol</p>
<p>integrand_bounds[1] ~ frequency at which |h|/(sqrt S) ~signal_to_noise +/- tol </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">params</td><td>Parameters of the waveform </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sensitivity_curve</td><td>Sensitivity curve to use (must be one of the analytic curves in the detector_utilitiy file </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fmin</td><td>minimum frequency to use (specific to the detector) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fmax</td><td>max frequency to use (specific to the detector) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">signal_to_noise</td><td>Target ratio of |h|/ sqrt(S) (typically ~0.1) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tol</td><td>This is a numerical algorithm, so the tolerance must be specified </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">integration_bounds</td><td>bounds fo the integral shape -- [2] -- (fmin,fmax) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d7ec6fc6fb00649edbba1122b64db1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7ec6fc6fb00649edbba1122b64db1b">&#9670;&nbsp;</a></span>integration_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int integration_interval </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>integration_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sensitivity_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>freq_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the integration bounds for the log likelihood or fisher given some observation time, sampling frequency, detector, and sensitivity curve. </p>
<p>Sensitivity curve has to be one of the options in detector_util analytic options</p>
<p>The current scheme is to use the frequency bounds determined by the SNR if the binary spends less than the integration time in band. If the merger spends more time in band than the integration time, the frequencies are determined to be (f_integration_time, f_high_band)</p>
<p>Accounts for the integration time, unlike the integration_bounds routine</p>
<p>returns 0 if successful, returns 1 if bounds could not be found due to roundoff, and returns 2 if entirely unsuccessful </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampling_freq</td><td>Frequency at which the detector operates </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">integration_time</td><td>Time of observation in seconds </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detector</td><td>Detector to use for the response function </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sensitivity_curve</td><td>Sensitivity curve to use -- must match analytic choices in detector_util </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>method to use for the waveform generation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">params</td><td>parameters of the source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">freq_bounds</td><td>Output bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3400a327a02e56c1b8defbd342d0cfee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3400a327a02e56c1b8defbd342d0cfee">&#9670;&nbsp;</a></span>Tbm_to_freq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tbm_to_freq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Tbm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to Calculate the time before merger using numerical methods. </p>
<p>Uses numerical &ndash; omp safe and thread safe </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Generation parameters of the source </td></tr>
    <tr><td class="paramname">generation_method</td><td>Generation method for the waveform </td></tr>
    <tr><td class="paramname">Tbm</td><td>target time before merger </td></tr>
    <tr><td class="paramname">freq</td><td>Frequency at the input time before merger </td></tr>
    <tr><td class="paramname">tol</td><td>Tolerance for the scheme </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab50c071471073e81a08351efb9594313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50c071471073e81a08351efb9594313">&#9670;&nbsp;</a></span>threshold_times() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void threshold_times </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>freqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>SN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>SNR_thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>threshold_times_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility for calculating the threshold times before merger that result in an SNR&gt;SNR_thresh. </p>
<p>See arXiv 1902.00021</p>
<p>Binary must merge within time T_wait</p>
<p>SNR is calculated with frequencies [f(t_mer),f(t_mer-T_obs)] or [f(t_mer),0] depending on whether the binary has merged or not</p>
<p>Assumes sky average &ndash; Only supports PhenomD for now &ndash; No angular dependence used ( only uses plus polarization &ndash; assumes iota = psi = 0 )</p>
<p>Assumes this is for multiband &ndash; ie stellar mass BHs &ndash; Only uses pn approximation of time frequency relation</p>
<p>If no time before merger satisfies the requirements, both are set to -1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>Generation method to use for the waveform </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">T_obs</td><td>Observation time -- also specifies the frequency spacing (\delta f = 1./T_obs) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">T_wait</td><td>Wait time -- Maximum time for binaries to coalesce </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">freqs</td><td>Maximum frequency array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">SN</td><td>Noise curve array, should be prepopulated from f_lower to f_upper with spacing 1./T_obs </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>Length of maximum frequency array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">SNR_thresh</td><td>Threshold SNR </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">threshold_times_out</td><td>Output frequencies </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tolerance</td><td>Percent tolerance on SNR search </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8404fb320da8cbbf323284e98c915b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8404fb320da8cbbf323284e98c915b1a">&#9670;&nbsp;</a></span>threshold_times() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void threshold_times </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>SN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>SNR_thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>threshold_times_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility for calculating the threshold times before merger that result in an SNR&gt;SNR_thresh. </p>
<p>See arXiv 1902.00021</p>
<p>Binary must merge within time T_wait</p>
<p>SNR is calculated with frequencies [f(t_mer),f(t_mer-T_obs)] or [f(t_mer),0] depending on whether the binary has merged or not</p>
<p>Assumes sky average &ndash; Only supports PhenomD for now</p>
<p>If no time before merger satisfies the requirements, both are set to -1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>Generation method to use for the waveform </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">T_obs</td><td>Observation time -- also specifies the frequency spacing (\delta f = 1./T_obs) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">T_wait</td><td>Wait time -- Maximum time for binaries to coalesce </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">f_lower</td><td>Lower bound of search </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">f_upper</td><td>upper bound of search </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">SN</td><td>Noise curve name </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">SNR_thresh</td><td>Threshold SNR </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">threshold_times_out</td><td>Output frequencies </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tolerance</td><td>Percent tolerance on SNR search </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61791d5e6231ea72ce813aa3501a8ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61791d5e6231ea72ce813aa3501a8ee4">&#9670;&nbsp;</a></span>threshold_times_gsl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int threshold_times_gsl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>SN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>SNR_thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>threshold_times_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_integration_workspace *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility for calculating the threshold times before merger that result in an SNR&gt;SNR_thresh &ndash;GSL quad integration implementation. </p>
<p>See arXiv 1902.00021</p>
<p>Binary must merge within time T_wait</p>
<p>SNR is calculated with frequencies [f(t_mer),f(t_mer-T_obs)] or [f(t_mer),0] depending on whether the binary has merged or not</p>
<p>Assumes sky average &ndash; Only supports PhenomD for now &ndash; No angular dependence used ( only uses plus polarization &ndash; assumes iota = psi = 0 )</p>
<p>Assumes this is for multiband &ndash; ie stellar mass BHs &ndash; Only uses pn approximation of time frequency relation</p>
<p>If no time before merger satisfies the requirements, both are set to -1</p>
<p>ALL temporal quantities in seconds or Hz</p>
<p>Return values: </p><pre class="fragment">0 -- success

11-- Failure: SNR was 0 in lower bound

12-- Failure: SNR was 0 in upper bound

13 -- partial success: Closest values output, but roundoff error prevented the routine from reaching the desired accuracy
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">generation_method</td><td>Generation method to use for the waveform </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">T_obs</td><td>Observation time -- also specifies the frequency spacing (\delta f = 1./T_obs) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">T_wait</td><td>Wait time -- Maximum time for binaries to coalesce </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fmin</td><td>Maximum frequency array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fmax</td><td>Maximum frequency array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">SN</td><td>Noise curve array, should be prepopulated from f_lower to f_upper with spacing 1./T_obs </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">SNR_thresh</td><td>Threshold SNR </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">threshold_times_out</td><td>Output times </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tolerance</td><td>Percent tolerance on SNR search </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c78a73b052376ec0c8acddcedb202bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c78a73b052376ec0c8acddcedb202bd">&#9670;&nbsp;</a></span>time_phase_corrected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void time_phase_corrected </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correct_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mapping from phase to time NUMERICAL. </p>
<p>Made for use with detectors like LISA</p>
<p>Using <a href="https://arxiv.org/abs/1809.04799">https://arxiv.org/abs/1809.04799</a> t = (1/2PI) d phi/ d f</p>
<p>This breaks down near merger,so at fRD, the relationship between frequency and time is extrapolated as a line</p>
<p>Currently, just uses <a class="el" href="classIMRPhenomD.html">IMRPhenomD</a> as a proxy regardless of what method is being used, as this is the analytically known function</p>
<p>For <a class="el" href="classIMRPhenomPv2.html">IMRPhenomPv2</a>, the phase has to be wrapped, because arctan is taken of the waveform because of the euler rotations. This might make the numerical derivative unpredictable</p>
<p>Just uses a second order numerical derivative for now </p>

</div>
</div>
<a id="a7b6f9e72d0309cfbc84a0e108708c635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6f9e72d0309cfbc84a0e108708c635">&#9670;&nbsp;</a></span>time_phase_corrected_autodiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void time_phase_corrected_autodiff </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgen__params__base.html">gen_params_base</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>generation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correct_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>tapes_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mapping from phase to time AUTODIFFERENTIATION using ADOL-C. </p>
<p>This is NOT autodiff safe. ADOL-C does not support wrapping a section of code as active twice. To find the derivative of this function, you must use the hessian function of ADOL-C</p>
<p>Made for use with detectors like LISA</p>
<p>Using <a href="https://arxiv.org/abs/1809.04799">https://arxiv.org/abs/1809.04799</a> t = (1/2PI) d phi/ d f</p>
<p>This breaks down near merger,so at fRD, the relationship between frequency and time is extrapolated as a line</p>
<p>Currently, just uses <a class="el" href="classIMRPhenomD.html">IMRPhenomD</a> as a proxy regardless of what method is being used, as this is the analytically known function</p>
<p>For <a class="el" href="classIMRPhenomPv2.html">IMRPhenomPv2</a>, the phase has to be wrapped, because arctan is taken of the waveform because of the euler rotations. This might make the numerical derivative unpredictable </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
